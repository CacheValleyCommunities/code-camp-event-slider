{"ast":null,"code":"var _jsxFileName = \"/Users/brentdalling/Projects/code-camp-event-slider/src/components/Canvas/Canvas.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from \"react\";\nimport \"./Canvas.css\";\nimport SponsorSprite from \"./Sprites/SponsorSprite\";\nimport GrassSprite1 from \"./Sprites/Set/GrassBlock1\";\nimport DirtBlock1Sprite from \"./Sprites/Set/Dirtblock1\";\nimport TreeSprite from \"./Sprites/TreeSprite\";\nimport BirchTreeSprite from \"./Sprites/TreeBirchSprite\";\nimport TreeFirStumpSprite from \"./Sprites/TreeFirStumpSprite\";\nimport BirchTreeSpriteTipped from \"./Sprites/TreeBirchSpriteTipped\";\nimport ProceduralSky from \"./Sprites/ProceduralSky\";\nimport ProceduralCloud from \"./Sprites/ProceduralCloud\";\nimport ProceduralTree from \"./Sprites/ProceduralTree\";\n// console.log = () => null;\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Canvas() {\n  _s();\n  const canvasRef = useRef(null);\n  const hasSetupBeenCalled = useRef(false);\n  const layers = useRef({\n    background: [],\n    stars: [],\n    mountains: [],\n    clouds: [],\n    trees: [],\n    'trees-2': [],\n    'trees-3': [],\n    'trees-4': [],\n    'trees-5': [],\n    sprites: [],\n    foreground: []\n  });\n  useEffect(() => {\n    const getRandomStartingXLocation = (canvasWidth, elementWidth) => {\n      // Generate a random X position starting from the right edge of the canvas\n      return getRandomNumber(0, canvasWidth);\n    };\n    const updateSpriteImage = async sprite => {\n      const img = new Image();\n      const nextImage = await sprite.config.getNextImage();\n      img.src = nextImage.url;\n      img.onload = () => {\n        sprite.image = img; // Store the loaded image in the element\n        sprite.width = nextImage.width;\n        sprite.height = nextImage.height;\n      };\n    };\n    const getRandomNumber = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n\n    // Utility function to get a random color representing stars\n    const getRandomColor = () => {\n      const colors = [\"#FFFFFF\",\n      // White\n      \"#FFD700\",\n      // Gold\n      \"#FF4500\",\n      // Orange Red\n      \"#FF8C00\" // Dark Orange\n      ];\n      return colors[Math.floor(Math.random() * colors.length)];\n    };\n    const createElement = async (type, config, layer, delay = 0) => {\n      // Create a promise that resolves after the specified delay\n      if (delay !== 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      const element = {\n        type,\n        ...config\n      };\n      if (type === \"sprite\") {\n        const img = new Image();\n        try {\n          const nextImage = await config.getNextImage();\n          config.height = nextImage.height;\n          config.width = nextImage.width;\n          img.src = nextImage.url;\n          element.image = img; // Store the loaded image in the element\n        } catch (e) {\n          console.log(\"Something went wrong creating sprite\", e);\n        }\n      }\n      element.config = config;\n\n      // Ensure the layer exists\n      if (!layers.current[layer]) {\n        console.error(`Layer \"${layer}\" does not exist. Available layers:`, Object.keys(layers.current));\n        return; // Exit early if the layer is invalid\n      }\n      layers.current[layer].push(element);\n      return element;\n    };\n    const drawElements = context => {\n      context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n      Object.keys(layers.current).forEach(layer => {\n        layers.current[layer].forEach(element => {\n          if (element.type === \"proceduralSky\") {\n            // Update and render procedural sky (no movement - stays static)\n            element.update();\n            element.render(context, 0); // No offset needed for static sky\n\n            // Sky doesn't move - remove all movement logic\n          } else if (element.type === \"proceduralCloud\") {\n            // Update and render procedural cloud\n            element.update();\n            element.render(context, element.x);\n\n            // Reset cloud position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = Math.random() * context.canvas.height * 0.15 + 20; // Higher Y position to match creation\n            }\n          } else if (element.type === \"proceduralTree\") {\n            // Update and render procedural tree\n            element.update();\n            element.render(context, offsetX);\n\n            // Reset tree position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = context.canvas.height - element.height; // Keep anchored to ground\n            }\n          } else if (element.type === \"rectangle\") {\n            context.fillStyle = element.color || \"rgba(255, 100, 100, 0.8)\";\n            context.fillRect(element.x, element.y, element.width, element.height);\n\n            // Move rectangle\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && element.config && !element.config.noRegen) {\n              element.x = context.canvas.width;\n            }\n            if (element.config && element.config.perTickTranslation) {\n              const {\n                modifier,\n                xFunc,\n                yFunc\n              } = element.config.perTickTranslation;\n              const yUnitChange = yFunc() * modifier;\n              element.y += yUnitChange * 10;\n              if (xFunc) {\n                const xUnitChange = yFunc() * modifier;\n                element.x += xUnitChange * 10;\n              }\n            }\n          } else if (element.type === \"sprite\") {\n            if (element.image.complete) {\n              context.drawImage(element.image, element.x, element.y, element.width, element.height);\n            }\n\n            // Move sprite\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && !element.config.noRegen) {\n              updateSpriteImage(element);\n              element.x = context.canvas.width; // Reset position to the right\n            }\n          }\n        });\n      });\n    };\n    const animate = context => {\n      drawElements(context);\n      requestAnimationFrame(() => animate(context));\n    };\n    const setup = async () => {\n      hasSetupBeenCalled.current = true;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      canvas.width = 1920;\n      canvas.height = 1080;\n\n      // Create example elements only once\n      if (layers.current.background.length === 0 || true) {\n        // Create procedural sky\n        await createElement(\"proceduralSky\", ProceduralSky(canvas, {\n          timeOfDay: 'night',\n          enableNoise: true,\n          noiseIntensity: 0.015,\n          // Reduced for better performance\n          enableSun: true,\n          // Enable moon for night\n          sunPosition: {\n            x: 0.2,\n            y: 0.15\n          },\n          // Moon position (upper left)\n          automaticTimeOfDay: false,\n          updateInterval: 10000,\n          // Update every 10 seconds for performance\n          animationSpeed: 0.0003 // Very slow animation for night sky\n        }), \"background\");\n        StartShootingStars(getRandomNumber, createElement, getRandomStartingXLocation, canvas, getRandomColor); // Start the first star creation\n\n        let width = 0;\n        const maxWidth = 1920 + 48;\n        const dirtHeight = canvas.height - 100 - 48;\n        const grassHeight = dirtHeight - 48;\n        while (width < maxWidth) {\n          await createElement(\"sprite\", DirtBlock1Sprite({\n            x: width,\n            y: dirtHeight,\n            width: 48,\n            height: 48\n          }), \"foreground\");\n          await createElement(\"sprite\", GrassSprite1({\n            x: width,\n            y: grassHeight,\n            width: 48,\n            height: 48\n          }), \"foreground\");\n          width += 48;\n        }\n        for (let i = 0; i < 100; i++) {\n          const starDimension = getRandomNumber(0.5, 3);\n          createElement(\"rectangle\", {\n            x: getRandomStartingXLocation(canvas.width, 5),\n            y: getRandomNumber(0, canvas.height),\n            width: starDimension,\n            height: starDimension,\n            speed: 0.1,\n            //getRandomNumber(0.01, 0.02),\n            color: getRandomColor(),\n            noRegen: false\n          }, \"stars\");\n        }\n\n        // Create procedural clouds with 8-bit style\n        for (let i = 0; i < 6; i++) {\n          await createElement(\"proceduralCloud\", ProceduralCloud(canvas, {\n            x: getRandomStartingXLocation(canvas.width, 200) + i * 400,\n            y: getRandomNumber(20, canvas.height * 0.15),\n            // Much higher in the sky\n            timeOfDay: 'night',\n            cloudTypes: i % 3 === 0 ? ['cirrus'] : i % 2 === 0 ? ['stratus'] : ['cumulus'],\n            size: getRandomNumber(15, 35) / 100,\n            // Even smaller base size\n            opacity: getRandomNumber(60, 90) / 100,\n            // More visible\n            speed: getRandomNumber(10, 25) / 100,\n            // Slower for retro feel\n            widthMultiplier: getRandomNumber(40, 100) / 100,\n            // Much more variation in width\n            heightMultiplier: getRandomNumber(30, 70) / 100 // Much more variation in height\n          }), \"clouds\");\n        }\n        createForest(canvas);\n\n        // await createCityScapeSprites(createElement, getRandomNumber, canvas);\n\n        createSponsorBillboard(canvas);\n      }\n      animate(context);\n    };\n    async function createForest(canvas) {\n      let height = canvas.height - 18 - 500;\n      for (let i = 0; i < 20; i++) {\n        createElement(\"sprite\", TreeSprite(getRandomNumber, canvas, {\n          x: getRandomNumber(0, canvas.width),\n          y: height\n        }), \"trees\");\n      }\n      for (let i = 0; i < 10; i++) {\n        createElement(\"sprite\", BirchTreeSprite(getRandomNumber, canvas, {\n          x: getRandomNumber(0, canvas.width),\n          y: height + 150\n        }), \"trees-2\");\n      }\n      for (let i = 0; i < 6; i++) {\n        createElement(\"sprite\", TreeSprite(getRandomNumber, canvas, {\n          x: getRandomNumber(0, canvas.width),\n          y: height + 15\n        }), \"trees-3\");\n      }\n      for (let i = 0; i < 5; i++) {\n        createElement(\"sprite\", TreeFirStumpSprite(getRandomNumber, canvas, {\n          x: getRandomNumber(0, canvas.width),\n          y: height + 300\n        }), \"trees-4\");\n      }\n      for (let i = 0; i < 5; i++) {\n        createElement(\"sprite\", BirchTreeSpriteTipped(getRandomNumber, canvas, {\n          x: getRandomNumber(0, canvas.width),\n          y: height + 225\n        }), \"trees-5\");\n      }\n    }\n    async function createSponsorBillboard(canvas) {\n      let height = canvas.height - 96 * 3 - 300;\n      let coords = {\n        x: 0,\n        y: height - 300 // sprite height - footer height\n      };\n      await createElement(\"sprite\", SponsorSprite(getRandomNumber, canvas, coords), \"foreground\");\n    }\n    function StartShootingStars(getRandomNumber, createElement, getRandomStartingXLocation, canvas, getRandomColor) {\n      let pendingInterval = null;\n      const createStar = async () => {\n        // Wait for a random delay\n        await new Promise(resolve => setTimeout(resolve, getRandomNumber(100, 1000 * 6) * 1));\n\n        // Create a shooting star\n        await createShootingStar(createElement, getRandomStartingXLocation, canvas, getRandomNumber, getRandomColor);\n\n        // Check for the next star\n        pendingInterval = setTimeout(createStar, 1000); // Schedule the next star creation\n      };\n      pendingInterval = setTimeout(createStar, 1000); // Start the first star creation\n      return pendingInterval;\n    }\n    function createShootingStar(createElement, getRandomStartingXLocation, canvas, getRandomNumber, getRandomColor) {\n      const starDir = Math.random() < 0.5 ? -1 : 1;\n      const perYTranslate = getRandomNumber(0.01, 0.5);\n      createElement(\"rectangle\", {\n        x: getRandomStartingXLocation(canvas.width, 5),\n        y: getRandomNumber(200, 500),\n        width: getRandomNumber(1, 12),\n        height: 5,\n        speed: getRandomNumber(10, 20),\n        color: getRandomColor(),\n        noRegen: true,\n        perTickTranslation: {\n          x: -1,\n          y: -0.1,\n          modifier: starDir,\n          yFunc: () => perYTranslate\n        }\n      }, \"stars\", 5000);\n    }\n    if (!hasSetupBeenCalled.current) {\n      setup();\n    }\n  }, [layers]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app-canvas\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 432,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 431,\n    columnNumber: 5\n  }, this);\n}\n_s(Canvas, \"XQXQzfYgGZGvX4LavKWdB/68Njw=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useEffect","useRef","SponsorSprite","GrassSprite1","DirtBlock1Sprite","TreeSprite","BirchTreeSprite","TreeFirStumpSprite","BirchTreeSpriteTipped","ProceduralSky","ProceduralCloud","ProceduralTree","jsxDEV","_jsxDEV","Canvas","_s","canvasRef","hasSetupBeenCalled","layers","background","stars","mountains","clouds","trees","sprites","foreground","getRandomStartingXLocation","canvasWidth","elementWidth","getRandomNumber","updateSpriteImage","sprite","img","Image","nextImage","config","getNextImage","src","url","onload","image","width","height","min","max","Math","floor","random","getRandomColor","colors","length","createElement","type","layer","delay","Promise","resolve","setTimeout","element","e","console","log","current","error","Object","keys","push","drawElements","context","clearRect","canvas","forEach","update","render","x","y","offsetX","fillStyle","color","fillRect","speed","noRegen","perTickTranslation","modifier","xFunc","yFunc","yUnitChange","xUnitChange","complete","drawImage","animate","requestAnimationFrame","setup","getContext","timeOfDay","enableNoise","noiseIntensity","enableSun","sunPosition","automaticTimeOfDay","updateInterval","animationSpeed","StartShootingStars","maxWidth","dirtHeight","grassHeight","i","starDimension","cloudTypes","size","opacity","widthMultiplier","heightMultiplier","createForest","createSponsorBillboard","coords","pendingInterval","createStar","createShootingStar","starDir","perYTranslate","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/components/Canvas/Canvas.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport \"./Canvas.css\";\nimport SponsorSprite from \"./Sprites/SponsorSprite\";\nimport GrassSprite1 from \"./Sprites/Set/GrassBlock1\";\nimport DirtBlock1Sprite from \"./Sprites/Set/Dirtblock1\";\nimport TreeSprite from \"./Sprites/TreeSprite\";\nimport BirchTreeSprite from \"./Sprites/TreeBirchSprite\";\nimport TreeFirStumpSprite from \"./Sprites/TreeFirStumpSprite\";\nimport BirchTreeSpriteTipped from \"./Sprites/TreeBirchSpriteTipped\";\nimport ProceduralSky from \"./Sprites/ProceduralSky\";\nimport ProceduralCloud from \"./Sprites/ProceduralCloud\";\nimport ProceduralTree from \"./Sprites/ProceduralTree\";\n// console.log = () => null;\n\nfunction Canvas() {\n  const canvasRef = useRef(null);\n  const hasSetupBeenCalled = useRef(false);\n  const layers = useRef({\n    background: [],\n    stars: [],\n    mountains: [],\n    clouds: [],\n    trees: [],\n    'trees-2': [],\n    'trees-3': [],\n    'trees-4': [],\n    'trees-5': [],\n\n    sprites: [],\n    foreground: [],\n  });\n\n  useEffect(() => {\n    const getRandomStartingXLocation = (canvasWidth, elementWidth) => {\n      // Generate a random X position starting from the right edge of the canvas\n      return getRandomNumber(0, canvasWidth);\n    };\n\n    const updateSpriteImage = async (sprite) => {\n      const img = new Image();\n      const nextImage = await sprite.config.getNextImage();\n      img.src = nextImage.url;\n\n      img.onload = () => {\n        sprite.image = img; // Store the loaded image in the element\n        sprite.width = nextImage.width;\n        sprite.height = nextImage.height;\n      };\n    };\n\n    const getRandomNumber = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n\n    // Utility function to get a random color representing stars\n    const getRandomColor = () => {\n      const colors = [\n        \"#FFFFFF\", // White\n        \"#FFD700\", // Gold\n        \"#FF4500\", // Orange Red\n        \"#FF8C00\", // Dark Orange\n      ];\n\n      return colors[Math.floor(Math.random() * colors.length)];\n    };\n\n    const createElement = async (type, config, layer, delay = 0) => {\n      // Create a promise that resolves after the specified delay\n      if (delay !== 0) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n\n      const element = { type, ...config };\n\n      if (type === \"sprite\") {\n        const img = new Image();\n        try {\n          const nextImage = await config.getNextImage();\n          config.height = nextImage.height;\n          config.width = nextImage.width;\n          img.src = nextImage.url;\n          element.image = img; // Store the loaded image in the element\n        } catch (e) {\n          console.log(\"Something went wrong creating sprite\", e);\n        }\n      }\n\n      element.config = config;\n\n      // Ensure the layer exists\n      if (!layers.current[layer]) {\n        console.error(\n          `Layer \"${layer}\" does not exist. Available layers:`,\n          Object.keys(layers.current)\n        );\n        return; // Exit early if the layer is invalid\n      }\n\n      layers.current[layer].push(element);\n\n      return element;\n    };\n\n    const drawElements = (context) => {\n      context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n\n      Object.keys(layers.current).forEach((layer) => {\n        layers.current[layer].forEach((element) => {\n          if (element.type === \"proceduralSky\") {\n            // Update and render procedural sky (no movement - stays static)\n            element.update();\n            element.render(context, 0); // No offset needed for static sky\n\n            // Sky doesn't move - remove all movement logic\n          } else if (element.type === \"proceduralCloud\") {\n            // Update and render procedural cloud\n            element.update();\n            element.render(context, element.x);\n\n            // Reset cloud position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = Math.random() * context.canvas.height * 0.15 + 20; // Higher Y position to match creation\n            }\n          } else if (element.type === \"proceduralTree\") {\n            // Update and render procedural tree\n            element.update();\n            element.render(context, offsetX);\n\n            // Reset tree position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = context.canvas.height - element.height; // Keep anchored to ground\n            }\n          } else if (element.type === \"rectangle\") {\n            context.fillStyle = element.color || \"rgba(255, 100, 100, 0.8)\";\n            context.fillRect(\n              element.x,\n              element.y,\n              element.width,\n              element.height\n            );\n\n            // Move rectangle\n            element.x -= element.speed;\n            if (\n              element.x + element.width < 0 &&\n              element.config &&\n              !element.config.noRegen\n            ) {\n              element.x = context.canvas.width;\n            }\n\n            if (element.config && element.config.perTickTranslation) {\n              const { modifier, xFunc, yFunc } =\n                element.config.perTickTranslation;\n              const yUnitChange = yFunc() * modifier;\n              element.y += yUnitChange * 10;\n\n              if (xFunc) {\n                const xUnitChange = yFunc() * modifier;\n                element.x += xUnitChange * 10;\n              }\n            }\n          } else if (element.type === \"sprite\") {\n            if (element.image.complete) {\n              context.drawImage(\n                element.image,\n                element.x,\n                element.y,\n                element.width,\n                element.height\n              );\n            }\n\n            // Move sprite\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && !element.config.noRegen) {\n              updateSpriteImage(element);\n              element.x = context.canvas.width; // Reset position to the right\n            }\n          }\n        });\n      });\n    };\n\n    const animate = (context) => {\n      drawElements(context);\n      requestAnimationFrame(() => animate(context));\n    };\n\n    const setup = async () => {\n      hasSetupBeenCalled.current = true;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      canvas.width = 1920;\n      canvas.height = 1080;\n\n      // Create example elements only once\n      if (layers.current.background.length === 0 || true) {\n        // Create procedural sky\n        await createElement(\n          \"proceduralSky\",\n          ProceduralSky(canvas, {\n            timeOfDay: 'night',\n            enableNoise: true,\n            noiseIntensity: 0.015, // Reduced for better performance\n            enableSun: true, // Enable moon for night\n            sunPosition: { x: 0.2, y: 0.15 }, // Moon position (upper left)\n            automaticTimeOfDay: false,\n            updateInterval: 10000, // Update every 10 seconds for performance\n            animationSpeed: 0.0003 // Very slow animation for night sky\n          }),\n          \"background\"\n        );\n\n        StartShootingStars(\n          getRandomNumber,\n          createElement,\n          getRandomStartingXLocation,\n          canvas,\n          getRandomColor\n        ); // Start the first star creation\n\n        let width = 0;\n        const maxWidth = 1920 + 48;\n\n        const dirtHeight = canvas.height - 100 - 48;\n        const grassHeight = dirtHeight - 48;\n\n        while (width < maxWidth) {\n          await createElement(\n            \"sprite\",\n            DirtBlock1Sprite({\n              x: width,\n              y: dirtHeight,\n              width: 48,\n              height: 48,\n            }),\n            \"foreground\"\n          );\n          await createElement(\n            \"sprite\",\n            GrassSprite1({\n              x: width,\n              y: grassHeight,\n              width: 48,\n              height: 48,\n            }),\n            \"foreground\"\n          );\n\n          width += 48;\n        }\n\n        for (let i = 0; i < 100; i++) {\n          const starDimension = getRandomNumber(0.5, 3);\n\n          createElement(\n            \"rectangle\",\n            {\n              x: getRandomStartingXLocation(canvas.width, 5),\n              y: getRandomNumber(0, canvas.height),\n              width: starDimension,\n              height: starDimension,\n              speed: 0.1, //getRandomNumber(0.01, 0.02),\n              color: getRandomColor(),\n              noRegen: false,\n            },\n            \"stars\"\n          );\n        }\n\n        // Create procedural clouds with 8-bit style\n        for (let i = 0; i < 6; i++) {\n          await createElement(\n            \"proceduralCloud\",\n            ProceduralCloud(canvas, {\n              x: getRandomStartingXLocation(canvas.width, 200) + i * 400,\n              y: getRandomNumber(20, canvas.height * 0.15), // Much higher in the sky\n              timeOfDay: 'night',\n              cloudTypes: i % 3 === 0 ? ['cirrus'] : i % 2 === 0 ? ['stratus'] : ['cumulus'],\n              size: getRandomNumber(15, 35) / 100, // Even smaller base size\n              opacity: getRandomNumber(60, 90) / 100, // More visible\n              speed: getRandomNumber(10, 25) / 100,   // Slower for retro feel\n              widthMultiplier: getRandomNumber(40, 100) / 100, // Much more variation in width\n              heightMultiplier: getRandomNumber(30, 70) / 100  // Much more variation in height\n            }),\n            \"clouds\"\n          );\n        }\n\n        createForest(canvas);\n\n        // await createCityScapeSprites(createElement, getRandomNumber, canvas);\n\n        createSponsorBillboard(canvas);\n      }\n\n      animate(context);\n    };\n\n    async function createForest(canvas) {\n      let height = canvas.height - 18 - 500;\n\n      for (let i = 0; i < 20; i++) {\n        createElement(\n          \"sprite\",\n          TreeSprite(getRandomNumber, canvas, { x: getRandomNumber(0, canvas.width), y: height }),\n          \"trees\"\n        )\n      }\n\n      for (let i = 0; i < 10; i++) {\n        createElement(\n          \"sprite\",\n          BirchTreeSprite(getRandomNumber, canvas, { x: getRandomNumber(0, canvas.width), y: height + 150 }),\n          \"trees-2\"\n        )\n      }\n\n      for (let i = 0; i < 6; i++) {\n        createElement(\n          \"sprite\",\n          TreeSprite(getRandomNumber, canvas, { x: getRandomNumber(0, canvas.width), y: height + 15 }),\n          \"trees-3\"\n        )\n      }\n\n      for (let i = 0; i < 5; i++) {\n        createElement(\n          \"sprite\",\n          TreeFirStumpSprite(getRandomNumber, canvas, { x: getRandomNumber(0, canvas.width), y: height + 300 }),\n          \"trees-4\"\n        )\n      }\n\n      for (let i = 0; i < 5; i++) {\n        createElement(\n          \"sprite\",\n          BirchTreeSpriteTipped(getRandomNumber, canvas, { x: getRandomNumber(0, canvas.width), y: height + 225 }),\n          \"trees-5\"\n        )\n      }\n    }\n\n    async function createSponsorBillboard(canvas) {\n      let height = canvas.height - (96 * 3) - 300;\n\n      let coords = {\n        x: 0,\n        y: height - 300, // sprite height - footer height\n      };\n\n      await createElement(\n        \"sprite\",\n        SponsorSprite(getRandomNumber, canvas, coords),\n        \"foreground\"\n      );\n    }\n\n    function StartShootingStars(\n      getRandomNumber,\n      createElement,\n      getRandomStartingXLocation,\n      canvas,\n      getRandomColor\n    ) {\n      let pendingInterval = null;\n\n      const createStar = async () => {\n        // Wait for a random delay\n        await new Promise((resolve) =>\n          setTimeout(resolve, getRandomNumber(100, 1000 * 6) * 1)\n        );\n\n        // Create a shooting star\n        await createShootingStar(\n          createElement,\n          getRandomStartingXLocation,\n          canvas,\n          getRandomNumber,\n          getRandomColor\n        );\n\n        // Check for the next star\n        pendingInterval = setTimeout(createStar, 1000); // Schedule the next star creation\n      };\n\n      pendingInterval = setTimeout(createStar, 1000); // Start the first star creation\n      return pendingInterval;\n    }\n\n    function createShootingStar(\n      createElement,\n      getRandomStartingXLocation,\n      canvas,\n      getRandomNumber,\n      getRandomColor\n    ) {\n      const starDir = Math.random() < 0.5 ? -1 : 1;\n      const perYTranslate = getRandomNumber(0.01, 0.5);\n      createElement(\n        \"rectangle\",\n        {\n          x: getRandomStartingXLocation(canvas.width, 5),\n          y: getRandomNumber(200, 500),\n          width: getRandomNumber(1, 12),\n          height: 5,\n          speed: getRandomNumber(10, 20),\n          color: getRandomColor(),\n          noRegen: true,\n          perTickTranslation: {\n            x: -1,\n            y: -0.1,\n            modifier: starDir,\n            yFunc: () => perYTranslate,\n          },\n        },\n        \"stars\",\n        5000\n      );\n    }\n\n    if (!hasSetupBeenCalled.current) {\n      setup();\n    }\n  }, [layers]);\n\n  return (\n    <div className=\"app-canvas\">\n      <canvas ref={canvasRef}></canvas>\n    </div>\n  );\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}