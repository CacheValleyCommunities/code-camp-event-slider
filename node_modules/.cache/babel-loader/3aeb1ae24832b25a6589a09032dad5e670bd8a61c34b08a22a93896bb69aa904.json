{"ast":null,"code":"/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\nexport class CloudGenerator {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n    this.colorPalette = new ColorPalette();\n\n    // Configuration options\n    this.options = {\n      timeOfDay: options.timeOfDay || 'day',\n      cloudTypes: options.cloudTypes || ['cumulus'],\n      density: options.density || 0.3,\n      size: options.size || 1.0,\n      opacity: options.opacity || 0.8,\n      speed: options.speed || 0.2,\n      noiseScale: options.noiseScale || 0.005,\n      animationSpeed: options.animationSpeed || 0.001,\n      updateInterval: options.updateInterval || 15000,\n      // Update every 15 seconds\n      ...options\n    };\n    this.time = 0;\n    this.lastUpdateTime = 0;\n    this.cloudCache = new Map();\n\n    // Initialize color palette\n    this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n  } /**\n    * Generate a single cloud shape using Mario-style design\n    * @param {number} width - Cloud width\n    * @param {number} height - Cloud height\n    * @param {string} type - Cloud type (all will be Mario-style)\n    * @returns {ImageData} Generated cloud image data\n    */\n  generateCloudShape(width, height, type = 'cumulus') {\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n\n    // Mario cloud colors (simple white with slight variations)\n    const cloudColors = this.createMarioCloudPalette();\n\n    // 16x16 pixel blocks for authentic Mario feel\n    const pixelSize = 16;\n    const gridWidth = Math.ceil(width / pixelSize);\n    const gridHeight = Math.ceil(height / pixelSize);\n\n    // Create Mario-style cloud pattern\n    this.drawMarioCloud(offscreenCtx, gridWidth, gridHeight, pixelSize, cloudColors);\n    return offscreenCanvas;\n  }\n\n  /**\n   * Draw Mario-style cloud using predefined patterns\n   * @param {CanvasRenderingContext2D} ctx - Canvas context\n   * @param {number} gridWidth - Grid width in blocks\n   * @param {number} gridHeight - Grid height in blocks\n   * @param {number} pixelSize - Size of each pixel block\n   * @param {Array} colors - Color palette\n   */\n  drawMarioCloud(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    // Mario cloud pattern (simplified)\n    // Create puffy round cloud with 3-4 bumps\n    const centerX = Math.floor(gridWidth / 2);\n    const centerY = Math.floor(gridHeight / 2);\n\n    // Main cloud body pattern\n    for (let gridY = 0; gridY < gridHeight; gridY++) {\n      for (let gridX = 0; gridX < gridWidth; gridX++) {\n        let shouldDrawPixel = false;\n        let colorIndex = 0;\n\n        // Calculate relative position from center\n        const relX = gridX - centerX;\n        const relY = gridY - centerY;\n\n        // Mario cloud shape logic - create rounded bumpy cloud\n        if (this.isMarioCloudPixel(relX, relY, gridWidth, gridHeight)) {\n          shouldDrawPixel = true;\n\n          // Determine shading based on position\n          if (relY < -1) {\n            colorIndex = 0; // Top highlight\n          } else if (relY > 1) {\n            colorIndex = 2; // Bottom shadow\n          } else if (relX < -2 || relX > 2) {\n            colorIndex = 1; // Side shading\n          } else {\n            colorIndex = 0; // Main body\n          }\n        }\n        if (shouldDrawPixel) {\n          ctx.fillStyle = colors[colorIndex];\n          ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine if a pixel should be part of the Mario cloud\n   * @param {number} relX - Relative X position from center\n   * @param {number} relY - Relative Y position from center\n   * @param {number} gridWidth - Total grid width\n   * @param {number} gridHeight - Total grid height\n   * @returns {boolean} Whether pixel should be drawn\n   */\n  isMarioCloudPixel(relX, relY, gridWidth, gridHeight) {\n    // Create classic Mario cloud shape with multiple bumps\n    const maxRadius = Math.min(gridWidth, gridHeight) * 0.4;\n\n    // Main cloud body (oval)\n    const mainBody = relX * relX / (maxRadius * maxRadius) + relY * relY / (maxRadius * 0.7 * (maxRadius * 0.7)) <= 1;\n\n    // Add bumps for Mario-style puffiness\n    const bump1 = Math.sqrt((relX + maxRadius * 0.6) * (relX + maxRadius * 0.6) + (relY - maxRadius * 0.3) * (relY - maxRadius * 0.3)) <= maxRadius * 0.5;\n    const bump2 = Math.sqrt((relX - maxRadius * 0.6) * (relX - maxRadius * 0.6) + (relY - maxRadius * 0.3) * (relY - maxRadius * 0.3)) <= maxRadius * 0.5;\n    const bump3 = Math.sqrt(relX * relX + (relY - maxRadius * 0.8) * (relY - maxRadius * 0.8)) <= maxRadius * 0.4;\n    return mainBody || bump1 || bump2 || bump3;\n  }\n\n  /**\n   * Create Mario-style color palette for clouds\n   * @returns {Array} Array of color strings\n   */\n  createMarioCloudPalette() {\n    // Classic Mario cloud colors - bright white with subtle shading\n    return ['#FFFFFF',\n    // Main white\n    '#E8E8E8',\n    // Light gray for side shading\n    '#D0D0D0',\n    // Darker gray for bottom shadow\n    '#F8F8F8' // Bright highlight\n    ];\n  }\n\n  /**\n   * Create 8-bit style color palette for clouds\n   * @param {Object} palette - Base color palette\n   * @returns {Array} Array of color strings\n   */\n  create8BitCloudPalette(palette) {\n    const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n    const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n\n    // Create 4-color palette for 8-bit look\n    const colors = [];\n    for (let i = 0; i < 4; i++) {\n      const factor = i / 3;\n      const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * factor);\n      const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * factor);\n      const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * factor);\n\n      // Quantize colors to 8-bit levels (reduce color depth)\n      const quantizedR = Math.floor(r / 32) * 32;\n      const quantizedG = Math.floor(g / 32) * 32;\n      const quantizedB = Math.floor(b / 32) * 32;\n      colors.push(`rgba(${quantizedR}, ${quantizedG}, ${quantizedB}, ${this.options.opacity})`);\n    }\n    return colors;\n  }\n\n  /**\n   * Get cloud parameters based on cloud type\n   * @param {string} type - Cloud type\n   * @returns {Object} Cloud generation parameters\n   */\n  getCloudParameters(type) {\n    const params = {\n      cumulus: {\n        scale1: 0.02,\n        // Larger scale for chunkier pixels\n        scale2: 0.05,\n        octaves1: 2,\n        // Fewer octaves for simpler patterns\n        octaves2: 1,\n        persistence1: 0.8,\n        persistence2: 0.5,\n        falloffStrength: 1.2,\n        threshold: 0.3,\n        contrast: 2.5\n      },\n      stratus: {\n        scale1: 0.01,\n        scale2: 0.03,\n        octaves1: 3,\n        octaves2: 1,\n        persistence1: 0.7,\n        persistence2: 0.6,\n        falloffStrength: 0.6,\n        threshold: 0.2,\n        contrast: 2.0\n      },\n      cirrus: {\n        scale1: 0.03,\n        scale2: 0.08,\n        octaves1: 2,\n        octaves2: 1,\n        persistence1: 0.9,\n        persistence2: 0.4,\n        falloffStrength: 1.8,\n        threshold: 0.4,\n        contrast: 3.5\n      }\n    };\n    return params[type] || params.cumulus;\n  }\n\n  /**\n   * Create a cloud instance\n   * @param {Object} config - Cloud configuration\n   * @returns {Object} Cloud object\n   */\n  createCloud(config) {\n    const cloudType = config.type || this.getRandomCloudType();\n    const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n    const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n    const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n    // Check cache for similar cloud\n    const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n    let cloudCanvas = this.cloudCache.get(cacheKey);\n    if (!cloudCanvas) {\n      cloudCanvas = this.generateCloudShape(width, height, cloudType);\n      this.cloudCache.set(cacheKey, cloudCanvas);\n\n      // Limit cache size\n      if (this.cloudCache.size > 20) {\n        const firstKey = this.cloudCache.keys().next().value;\n        this.cloudCache.delete(firstKey);\n      }\n    }\n    return {\n      type: 'proceduralCloud',\n      x: config.x || this.canvas.width,\n      y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n      width: width,\n      height: height,\n      cloudType: cloudType,\n      cloudCanvas: cloudCanvas,\n      speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n      opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n      lastUpdateTime: Date.now(),\n      // Update method\n      update(deltaTime) {\n        // Clouds don't need frequent updates, just movement\n        this.x -= this.speed;\n      },\n      // Render method\n      render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n        ctx.restore();\n      }\n    };\n  }\n\n  /**\n   * Get random cloud type based on configured types\n   * @returns {string} Cloud type\n   */\n  getRandomCloudType() {\n    const types = this.options.cloudTypes;\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get random float between min and max\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @returns {number} Random float\n   */\n  getRandomFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  /**\n   * Update cloud generation\n   * @param {number} deltaTime - Time since last update\n   */\n  update(deltaTime = 16) {\n    this.time += this.options.animationSpeed * deltaTime;\n  }\n\n  /**\n   * Set time of day and update cloud colors\n   * @param {string} timeOfDay - New time of day\n   */\n  setTimeOfDay(timeOfDay) {\n    this.options.timeOfDay = timeOfDay;\n    this.colorPalette.setTimeOfDay(timeOfDay);\n    // Clear cache to regenerate clouds with new colors\n    this.cloudCache.clear();\n  }\n\n  /**\n   * Update configuration options\n   * @param {Object} newOptions - New options to apply\n   */\n  updateOptions(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    if (newOptions.timeOfDay) {\n      this.setTimeOfDay(newOptions.timeOfDay);\n    }\n    if (newOptions.seed) {\n      this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n      this.cloudCache.clear();\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.cloudCache.clear();\n  }\n}\nexport default CloudGenerator;","map":{"version":3,"names":["NoiseGenerator","ColorPalette","CloudGenerator","constructor","canvas","options","ctx","getContext","noiseGenerator","seed","Math","random","colorPalette","timeOfDay","cloudTypes","density","size","opacity","speed","noiseScale","animationSpeed","updateInterval","time","lastUpdateTime","cloudCache","Map","setTimeOfDay","generateCloudShape","width","height","type","offscreenCanvas","document","createElement","offscreenCtx","cloudColors","createMarioCloudPalette","pixelSize","gridWidth","ceil","gridHeight","drawMarioCloud","colors","centerX","floor","centerY","gridY","gridX","shouldDrawPixel","colorIndex","relX","relY","isMarioCloudPixel","fillStyle","fillRect","maxRadius","min","mainBody","bump1","sqrt","bump2","bump3","create8BitCloudPalette","palette","baseColor","hexToRgb","cloudBase","highlightColor","cloudHighlight","i","factor","r","round","g","b","quantizedR","quantizedG","quantizedB","push","getCloudParameters","params","cumulus","scale1","scale2","octaves1","octaves2","persistence1","persistence2","falloffStrength","threshold","contrast","stratus","cirrus","createCloud","config","cloudType","getRandomCloudType","baseSize","widthMultiplier","getRandomFloat","heightMultiplier","cacheKey","cloudCanvas","get","set","firstKey","keys","next","value","delete","x","y","Date","now","update","deltaTime","render","save","globalAlpha","drawImage","restore","types","length","max","clear","updateOptions","newOptions","destroy"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/graphics/generators/CloudGenerator.js"],"sourcesContent":["/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\n\nexport class CloudGenerator {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n        this.colorPalette = new ColorPalette();\n\n        // Configuration options\n        this.options = {\n            timeOfDay: options.timeOfDay || 'day',\n            cloudTypes: options.cloudTypes || ['cumulus'],\n            density: options.density || 0.3,\n            size: options.size || 1.0,\n            opacity: options.opacity || 0.8,\n            speed: options.speed || 0.2,\n            noiseScale: options.noiseScale || 0.005,\n            animationSpeed: options.animationSpeed || 0.001,\n            updateInterval: options.updateInterval || 15000, // Update every 15 seconds\n            ...options\n        };\n\n        this.time = 0;\n        this.lastUpdateTime = 0;\n        this.cloudCache = new Map();\n\n        // Initialize color palette\n        this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n    }    /**\n     * Generate a single cloud shape using Mario-style design\n     * @param {number} width - Cloud width\n     * @param {number} height - Cloud height\n     * @param {string} type - Cloud type (all will be Mario-style)\n     * @returns {ImageData} Generated cloud image data\n     */\n    generateCloudShape(width, height, type = 'cumulus') {\n        const offscreenCanvas = document.createElement('canvas');\n        const offscreenCtx = offscreenCanvas.getContext('2d');\n        offscreenCanvas.width = width;\n        offscreenCanvas.height = height;\n\n        // Mario cloud colors (simple white with slight variations)\n        const cloudColors = this.createMarioCloudPalette();\n\n        // 16x16 pixel blocks for authentic Mario feel\n        const pixelSize = 16;\n        const gridWidth = Math.ceil(width / pixelSize);\n        const gridHeight = Math.ceil(height / pixelSize);\n\n        // Create Mario-style cloud pattern\n        this.drawMarioCloud(offscreenCtx, gridWidth, gridHeight, pixelSize, cloudColors);\n\n        return offscreenCanvas;\n    }\n\n    /**\n     * Draw Mario-style cloud using predefined patterns\n     * @param {CanvasRenderingContext2D} ctx - Canvas context\n     * @param {number} gridWidth - Grid width in blocks\n     * @param {number} gridHeight - Grid height in blocks\n     * @param {number} pixelSize - Size of each pixel block\n     * @param {Array} colors - Color palette\n     */\n    drawMarioCloud(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        // Mario cloud pattern (simplified)\n        // Create puffy round cloud with 3-4 bumps\n        const centerX = Math.floor(gridWidth / 2);\n        const centerY = Math.floor(gridHeight / 2);\n\n        // Main cloud body pattern\n        for (let gridY = 0; gridY < gridHeight; gridY++) {\n            for (let gridX = 0; gridX < gridWidth; gridX++) {\n                let shouldDrawPixel = false;\n                let colorIndex = 0;\n\n                // Calculate relative position from center\n                const relX = gridX - centerX;\n                const relY = gridY - centerY;\n\n                // Mario cloud shape logic - create rounded bumpy cloud\n                if (this.isMarioCloudPixel(relX, relY, gridWidth, gridHeight)) {\n                    shouldDrawPixel = true;\n\n                    // Determine shading based on position\n                    if (relY < -1) {\n                        colorIndex = 0; // Top highlight\n                    } else if (relY > 1) {\n                        colorIndex = 2; // Bottom shadow\n                    } else if (relX < -2 || relX > 2) {\n                        colorIndex = 1; // Side shading\n                    } else {\n                        colorIndex = 0; // Main body\n                    }\n                }\n\n                if (shouldDrawPixel) {\n                    ctx.fillStyle = colors[colorIndex];\n                    ctx.fillRect(\n                        gridX * pixelSize,\n                        gridY * pixelSize,\n                        pixelSize,\n                        pixelSize\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Determine if a pixel should be part of the Mario cloud\n     * @param {number} relX - Relative X position from center\n     * @param {number} relY - Relative Y position from center\n     * @param {number} gridWidth - Total grid width\n     * @param {number} gridHeight - Total grid height\n     * @returns {boolean} Whether pixel should be drawn\n     */\n    isMarioCloudPixel(relX, relY, gridWidth, gridHeight) {\n        // Create classic Mario cloud shape with multiple bumps\n        const maxRadius = Math.min(gridWidth, gridHeight) * 0.4;\n\n        // Main cloud body (oval)\n        const mainBody = (relX * relX) / (maxRadius * maxRadius) +\n            (relY * relY) / ((maxRadius * 0.7) * (maxRadius * 0.7)) <= 1;\n\n        // Add bumps for Mario-style puffiness\n        const bump1 = Math.sqrt((relX + maxRadius * 0.6) * (relX + maxRadius * 0.6) +\n            (relY - maxRadius * 0.3) * (relY - maxRadius * 0.3)) <= maxRadius * 0.5;\n\n        const bump2 = Math.sqrt((relX - maxRadius * 0.6) * (relX - maxRadius * 0.6) +\n            (relY - maxRadius * 0.3) * (relY - maxRadius * 0.3)) <= maxRadius * 0.5;\n\n        const bump3 = Math.sqrt((relX) * (relX) +\n            (relY - maxRadius * 0.8) * (relY - maxRadius * 0.8)) <= maxRadius * 0.4;\n\n        return mainBody || bump1 || bump2 || bump3;\n    }\n\n    /**\n     * Create Mario-style color palette for clouds\n     * @returns {Array} Array of color strings\n     */\n    createMarioCloudPalette() {\n        // Classic Mario cloud colors - bright white with subtle shading\n        return [\n            '#FFFFFF', // Main white\n            '#E8E8E8', // Light gray for side shading\n            '#D0D0D0', // Darker gray for bottom shadow\n            '#F8F8F8'  // Bright highlight\n        ];\n    }\n\n    /**\n     * Create 8-bit style color palette for clouds\n     * @param {Object} palette - Base color palette\n     * @returns {Array} Array of color strings\n     */\n    create8BitCloudPalette(palette) {\n        const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n        const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n\n        // Create 4-color palette for 8-bit look\n        const colors = [];\n        for (let i = 0; i < 4; i++) {\n            const factor = i / 3;\n            const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * factor);\n            const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * factor);\n            const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * factor);\n\n            // Quantize colors to 8-bit levels (reduce color depth)\n            const quantizedR = Math.floor(r / 32) * 32;\n            const quantizedG = Math.floor(g / 32) * 32;\n            const quantizedB = Math.floor(b / 32) * 32;\n\n            colors.push(`rgba(${quantizedR}, ${quantizedG}, ${quantizedB}, ${this.options.opacity})`);\n        }\n\n        return colors;\n    }\n\n    /**\n     * Get cloud parameters based on cloud type\n     * @param {string} type - Cloud type\n     * @returns {Object} Cloud generation parameters\n     */    getCloudParameters(type) {\n        const params = {\n            cumulus: {\n                scale1: 0.02,   // Larger scale for chunkier pixels\n                scale2: 0.05,\n                octaves1: 2,    // Fewer octaves for simpler patterns\n                octaves2: 1,\n                persistence1: 0.8,\n                persistence2: 0.5,\n                falloffStrength: 1.2,\n                threshold: 0.3,\n                contrast: 2.5\n            },\n            stratus: {\n                scale1: 0.01,\n                scale2: 0.03,\n                octaves1: 3,\n                octaves2: 1,\n                persistence1: 0.7,\n                persistence2: 0.6,\n                falloffStrength: 0.6,\n                threshold: 0.2,\n                contrast: 2.0\n            },\n            cirrus: {\n                scale1: 0.03,\n                scale2: 0.08,\n                octaves1: 2,\n                octaves2: 1,\n                persistence1: 0.9,\n                persistence2: 0.4,\n                falloffStrength: 1.8,\n                threshold: 0.4,\n                contrast: 3.5\n            }\n        };\n\n        return params[type] || params.cumulus;\n    }\n\n    /**\n     * Create a cloud instance\n     * @param {Object} config - Cloud configuration\n     * @returns {Object} Cloud object\n     */\n    createCloud(config) {\n        const cloudType = config.type || this.getRandomCloudType();\n        const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n\n        const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n        const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n        // Check cache for similar cloud\n        const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n        let cloudCanvas = this.cloudCache.get(cacheKey);\n\n        if (!cloudCanvas) {\n            cloudCanvas = this.generateCloudShape(width, height, cloudType);\n            this.cloudCache.set(cacheKey, cloudCanvas);\n\n            // Limit cache size\n            if (this.cloudCache.size > 20) {\n                const firstKey = this.cloudCache.keys().next().value;\n                this.cloudCache.delete(firstKey);\n            }\n        }\n\n        return {\n            type: 'proceduralCloud',\n            x: config.x || this.canvas.width,\n            y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n            width: width,\n            height: height,\n            cloudType: cloudType,\n            cloudCanvas: cloudCanvas,\n            speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n            opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n            lastUpdateTime: Date.now(),\n\n            // Update method\n            update(deltaTime) {\n                // Clouds don't need frequent updates, just movement\n                this.x -= this.speed;\n            },\n\n            // Render method\n            render(ctx) {\n                ctx.save();\n                ctx.globalAlpha = this.opacity;\n                ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n                ctx.restore();\n            }\n        };\n    }\n\n    /**\n     * Get random cloud type based on configured types\n     * @returns {string} Cloud type\n     */\n    getRandomCloudType() {\n        const types = this.options.cloudTypes;\n        return types[Math.floor(Math.random() * types.length)];\n    }\n\n    /**\n     * Get random float between min and max\n     * @param {number} min - Minimum value\n     * @param {number} max - Maximum value\n     * @returns {number} Random float\n     */\n    getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Update cloud generation\n     * @param {number} deltaTime - Time since last update\n     */\n    update(deltaTime = 16) {\n        this.time += this.options.animationSpeed * deltaTime;\n    }\n\n    /**\n     * Set time of day and update cloud colors\n     * @param {string} timeOfDay - New time of day\n     */\n    setTimeOfDay(timeOfDay) {\n        this.options.timeOfDay = timeOfDay;\n        this.colorPalette.setTimeOfDay(timeOfDay);\n        // Clear cache to regenerate clouds with new colors\n        this.cloudCache.clear();\n    }\n\n    /**\n     * Update configuration options\n     * @param {Object} newOptions - New options to apply\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n\n        if (newOptions.timeOfDay) {\n            this.setTimeOfDay(newOptions.timeOfDay);\n        }\n\n        if (newOptions.seed) {\n            this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n            this.cloudCache.clear();\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.cloudCache.clear();\n    }\n}\n\nexport default CloudGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}