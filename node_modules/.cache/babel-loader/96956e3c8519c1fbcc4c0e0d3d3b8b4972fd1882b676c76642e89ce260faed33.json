{"ast":null,"code":"/**\n * Procedural Tree Generator\n * Creates pixel-perfect trees using L-system and fractal algorithms\n * Supports multiple tree types with Mario-style pixel art aesthetic\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\nexport class TreeGenerator {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n    this.colorPalette = new ColorPalette();\n\n    // Configuration options\n    this.options = {\n      timeOfDay: options.timeOfDay || 'day',\n      treeTypes: options.treeTypes || ['birch', 'fir', 'oak'],\n      season: options.season || 'summer',\n      pixelSize: options.pixelSize || 8,\n      // 8x8 pixel blocks for retro feel\n      windStrength: options.windStrength || 0.1,\n      animationSpeed: options.animationSpeed || 0.001,\n      ...options\n    };\n    this.time = 0;\n    this.treeCache = new Map();\n\n    // Initialize color palette\n    this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n  }\n\n  /**\n   * Generate a tree using pixel art style\n   * @param {number} width - Tree width\n   * @param {number} height - Tree height\n   * @param {string} type - Tree type\n   * @returns {Canvas} Generated tree canvas\n   */\n  generateTree(width, height, type = 'oak') {\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n\n    // Get tree colors based on type and season\n    const treeColors = this.getTreePalette(type);\n\n    // Grid-based drawing for pixel art style\n    const pixelSize = this.options.pixelSize;\n    const gridWidth = Math.ceil(width / pixelSize);\n    const gridHeight = Math.ceil(height / pixelSize);\n\n    // Draw tree based on type\n    switch (type) {\n      case 'birch':\n        this.drawBirchTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n        break;\n      case 'fir':\n        this.drawFirTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n        break;\n      case 'oak':\n        this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n        break;\n      case 'jungle':\n        this.drawJungleTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n        break;\n      default:\n        this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n    }\n    return offscreenCanvas;\n  }\n\n  /**\n   * Draw a Mario-style Birch tree\n   */\n  drawBirchTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.7);\n\n    // Draw trunk (white with black stripes for birch)\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX; x++) {\n        // Birch bark pattern - white with horizontal black stripes\n        const isStripe = (y - (gridHeight - trunkHeight)) % 4 === 0;\n        ctx.fillStyle = isStripe ? colors.trunkDark : colors.trunkLight;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw leaves (small, delicate crown)\n    const crownStartY = Math.floor(gridHeight * 0.2);\n    const crownHeight = Math.floor(gridHeight * 0.5);\n    for (let y = crownStartY; y < crownStartY + crownHeight; y++) {\n      for (let x = 0; x < gridWidth; x++) {\n        if (this.isBirchLeafPixel(x - centerX, y - crownStartY, gridWidth, crownHeight)) {\n          ctx.fillStyle = colors.leaves;\n          ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Fir tree (Christmas tree shape)\n   */\n  drawFirTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.2);\n\n    // Draw trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw triangular fir shape in layers\n    const layers = 4;\n    const layerHeight = Math.floor((gridHeight - trunkHeight) / layers);\n    for (let layer = 0; layer < layers; layer++) {\n      const layerY = layer * layerHeight;\n      const layerBottom = layerY + layerHeight + 2; // Overlap layers\n      const maxWidth = Math.min(gridWidth, (layer + 2) * 3);\n      for (let y = layerY; y < layerBottom && y < gridHeight - trunkHeight; y++) {\n        const widthAtY = Math.floor(maxWidth * (y - layerY + 1) / layerHeight);\n        const startX = centerX - Math.floor(widthAtY / 2);\n        const endX = centerX + Math.floor(widthAtY / 2);\n        for (let x = startX; x <= endX; x++) {\n          if (x >= 0 && x < gridWidth) {\n            // Add some randomness to edges for organic feel\n            const isEdge = x === startX || x === endX;\n            if (!isEdge || Math.random() > 0.3) {\n              ctx.fillStyle = colors.leaves;\n              ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Oak tree (round crown)\n   */\n  drawOakTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.4);\n\n    // Draw trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX + 1; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw round crown\n    const crownCenterY = Math.floor(gridHeight * 0.25);\n    const crownRadius = Math.min(gridWidth / 2 - 1, gridHeight * 0.35);\n    for (let y = 0; y < gridHeight - trunkHeight + 2; y++) {\n      for (let x = 0; x < gridWidth; x++) {\n        const dx = x - centerX;\n        const dy = y - crownCenterY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Create bumpy circular crown\n        const noise = this.noiseGenerator.perlin2D(x * 0.3, y * 0.3) * 2;\n        const adjustedRadius = crownRadius + noise;\n        if (distance <= adjustedRadius) {\n          // Add some holes for realistic look\n          const holeNoise = this.noiseGenerator.perlin2D(x * 0.5, y * 0.5);\n          if (holeNoise > -0.3) {\n            ctx.fillStyle = colors.leaves;\n            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Jungle tree (tall with broad leaves)\n   */\n  drawJungleTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.6);\n\n    // Draw tall trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 2; x <= centerX + 1; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw large palm-like leaves at top\n    const crownY = Math.floor(gridHeight * 0.1);\n    const crownHeight = Math.floor(gridHeight * 0.35);\n\n    // Create multiple palm fronds\n    for (let frond = 0; frond < 6; frond++) {\n      const angle = frond * Math.PI * 2 / 6;\n      const frondLength = Math.min(gridWidth / 2, gridHeight * 0.2);\n      for (let i = 0; i < frondLength; i++) {\n        const x = centerX + Math.cos(angle) * i;\n        const y = crownY + crownHeight / 2 + Math.sin(angle) * i * 0.5;\n        const gridX = Math.floor(x);\n        const gridY = Math.floor(y);\n        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {\n          ctx.fillStyle = colors.leaves;\n          ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if pixel should be part of birch leaves\n   */\n  isBirchLeafPixel(relX, relY, gridWidth, crownHeight) {\n    // Oval shape for birch crown\n    const a = gridWidth * 0.3;\n    const b = crownHeight * 0.4;\n    return relX * relX / (a * a) + relY * relY / (b * b) <= 1;\n  }\n\n  /**\n   * Get color palette for tree type and season\n   */\n  getTreePalette(type) {\n    const season = this.options.season;\n    const baseColors = {\n      birch: {\n        trunkLight: '#F8F8F8',\n        // White birch bark\n        trunkDark: '#404040',\n        // Black stripes\n        trunk: '#E8E8E8',\n        leaves: season === 'autumn' ? '#FFD700' : season === 'winter' ? '#F0F0F0' : '#90EE90'\n      },\n      fir: {\n        trunk: '#8B4513',\n        leaves: season === 'winter' ? '#0F5F0F' : '#228B22' // Darker green\n      },\n      oak: {\n        trunk: '#8B4513',\n        leaves: season === 'autumn' ? '#FF8C00' : season === 'winter' ? '#A0A0A0' : '#32CD32'\n      },\n      jungle: {\n        trunk: '#8B4513',\n        leaves: '#228B22' // Always green\n      }\n    };\n    return baseColors[type] || baseColors.oak;\n  }\n\n  /**\n   * Create a tree instance\n   */\n  createTree(config) {\n    const treeType = config.type || this.getRandomTreeType();\n    const baseSize = Math.min(this.canvas.width, this.canvas.height) * 0.15; // Smaller than clouds\n\n    const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.8, 1.2)));\n    const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(1.5, 2.5)));\n\n    // Check cache\n    const cacheKey = `${treeType}_${width}_${height}_${this.options.season}`;\n    let treeCanvas = this.treeCache.get(cacheKey);\n    if (!treeCanvas) {\n      treeCanvas = this.generateTree(width, height, treeType);\n      this.treeCache.set(cacheKey, treeCanvas);\n\n      // Limit cache size\n      if (this.treeCache.size > 30) {\n        const firstKey = this.treeCache.keys().next().value;\n        this.treeCache.delete(firstKey);\n      }\n    }\n    return {\n      type: 'proceduralTree',\n      x: config.x || this.canvas.width,\n      y: config.y || this.canvas.height - height,\n      width: width,\n      height: height,\n      treeType: treeType,\n      treeCanvas: treeCanvas,\n      speed: config.speed || this.getRandomFloat(0.5, 1.2),\n      opacity: config.opacity || 1.0,\n      lastUpdateTime: Date.now(),\n      // Update method\n      update(deltaTime) {\n        // Trees move with the parallax\n        this.x -= this.speed;\n      },\n      // Render method\n      render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        ctx.drawImage(this.treeCanvas, this.x, this.y, this.width, this.height);\n        ctx.restore();\n      }\n    };\n  }\n\n  /**\n   * Get random tree type\n   */\n  getRandomTreeType() {\n    const types = this.options.treeTypes;\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get random float between min and max\n   */\n  getRandomFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  /**\n   * Update tree generation\n   */\n  update(deltaTime = 16) {\n    this.time += this.options.animationSpeed * deltaTime;\n  }\n\n  /**\n   * Set season and update tree colors\n   */\n  setSeason(season) {\n    this.options.season = season;\n    this.treeCache.clear(); // Regenerate with new season colors\n  }\n\n  /**\n   * Set time of day\n   */\n  setTimeOfDay(timeOfDay) {\n    this.options.timeOfDay = timeOfDay;\n    this.colorPalette.setTimeOfDay(timeOfDay);\n  }\n\n  /**\n   * Update configuration options\n   */\n  updateOptions(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    if (newOptions.season) {\n      this.setSeason(newOptions.season);\n    }\n    if (newOptions.timeOfDay) {\n      this.setTimeOfDay(newOptions.timeOfDay);\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.treeCache.clear();\n  }\n}\nexport default TreeGenerator;","map":{"version":3,"names":["NoiseGenerator","ColorPalette","TreeGenerator","constructor","canvas","options","ctx","getContext","noiseGenerator","seed","Math","random","colorPalette","timeOfDay","treeTypes","season","pixelSize","windStrength","animationSpeed","time","treeCache","Map","setTimeOfDay","generateTree","width","height","type","offscreenCanvas","document","createElement","offscreenCtx","treeColors","getTreePalette","gridWidth","ceil","gridHeight","drawBirchTree","drawFirTree","drawOakTree","drawJungleTree","colors","centerX","floor","trunkHeight","y","x","isStripe","fillStyle","trunkDark","trunkLight","fillRect","crownStartY","crownHeight","isBirchLeafPixel","leaves","trunk","layers","layerHeight","layer","layerY","layerBottom","maxWidth","min","widthAtY","startX","endX","isEdge","crownCenterY","crownRadius","dx","dy","distance","sqrt","noise","perlin2D","adjustedRadius","holeNoise","crownY","frond","angle","PI","frondLength","i","cos","sin","gridX","gridY","relX","relY","a","b","baseColors","birch","fir","oak","jungle","createTree","config","treeType","getRandomTreeType","baseSize","round","widthMultiplier","getRandomFloat","heightMultiplier","cacheKey","treeCanvas","get","set","size","firstKey","keys","next","value","delete","speed","opacity","lastUpdateTime","Date","now","update","deltaTime","render","save","globalAlpha","drawImage","restore","types","length","max","setSeason","clear","updateOptions","newOptions","destroy"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/graphics/generators/TreeGenerator.js"],"sourcesContent":["/**\n * Procedural Tree Generator\n * Creates pixel-perfect trees using L-system and fractal algorithms\n * Supports multiple tree types with Mario-style pixel art aesthetic\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\n\nexport class TreeGenerator {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n        this.colorPalette = new ColorPalette();\n\n        // Configuration options\n        this.options = {\n            timeOfDay: options.timeOfDay || 'day',\n            treeTypes: options.treeTypes || ['birch', 'fir', 'oak'],\n            season: options.season || 'summer',\n            pixelSize: options.pixelSize || 8, // 8x8 pixel blocks for retro feel\n            windStrength: options.windStrength || 0.1,\n            animationSpeed: options.animationSpeed || 0.001,\n            ...options\n        };\n\n        this.time = 0;\n        this.treeCache = new Map();\n\n        // Initialize color palette\n        this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n    }\n\n    /**\n     * Generate a tree using pixel art style\n     * @param {number} width - Tree width\n     * @param {number} height - Tree height\n     * @param {string} type - Tree type\n     * @returns {Canvas} Generated tree canvas\n     */\n    generateTree(width, height, type = 'oak') {\n        const offscreenCanvas = document.createElement('canvas');\n        const offscreenCtx = offscreenCanvas.getContext('2d');\n        offscreenCanvas.width = width;\n        offscreenCanvas.height = height;\n\n        // Get tree colors based on type and season\n        const treeColors = this.getTreePalette(type);\n        \n        // Grid-based drawing for pixel art style\n        const pixelSize = this.options.pixelSize;\n        const gridWidth = Math.ceil(width / pixelSize);\n        const gridHeight = Math.ceil(height / pixelSize);\n\n        // Draw tree based on type\n        switch (type) {\n            case 'birch':\n                this.drawBirchTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                break;\n            case 'fir':\n                this.drawFirTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                break;\n            case 'oak':\n                this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                break;\n            case 'jungle':\n                this.drawJungleTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                break;\n            default:\n                this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n        }\n\n        return offscreenCanvas;\n    }\n\n    /**\n     * Draw a Mario-style Birch tree\n     */\n    drawBirchTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.7);\n        \n        // Draw trunk (white with black stripes for birch)\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX; x++) {\n                // Birch bark pattern - white with horizontal black stripes\n                const isStripe = (y - (gridHeight - trunkHeight)) % 4 === 0;\n                ctx.fillStyle = isStripe ? colors.trunkDark : colors.trunkLight;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw leaves (small, delicate crown)\n        const crownStartY = Math.floor(gridHeight * 0.2);\n        const crownHeight = Math.floor(gridHeight * 0.5);\n        \n        for (let y = crownStartY; y < crownStartY + crownHeight; y++) {\n            for (let x = 0; x < gridWidth; x++) {\n                if (this.isBirchLeafPixel(x - centerX, y - crownStartY, gridWidth, crownHeight)) {\n                    ctx.fillStyle = colors.leaves;\n                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Fir tree (Christmas tree shape)\n     */\n    drawFirTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.2);\n        \n        // Draw trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw triangular fir shape in layers\n        const layers = 4;\n        const layerHeight = Math.floor((gridHeight - trunkHeight) / layers);\n        \n        for (let layer = 0; layer < layers; layer++) {\n            const layerY = layer * layerHeight;\n            const layerBottom = layerY + layerHeight + 2; // Overlap layers\n            const maxWidth = Math.min(gridWidth, (layer + 2) * 3);\n            \n            for (let y = layerY; y < layerBottom && y < gridHeight - trunkHeight; y++) {\n                const widthAtY = Math.floor(maxWidth * (y - layerY + 1) / layerHeight);\n                const startX = centerX - Math.floor(widthAtY / 2);\n                const endX = centerX + Math.floor(widthAtY / 2);\n                \n                for (let x = startX; x <= endX; x++) {\n                    if (x >= 0 && x < gridWidth) {\n                        // Add some randomness to edges for organic feel\n                        const isEdge = x === startX || x === endX;\n                        if (!isEdge || Math.random() > 0.3) {\n                            ctx.fillStyle = colors.leaves;\n                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Oak tree (round crown)\n     */\n    drawOakTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.4);\n        \n        // Draw trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX + 1; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw round crown\n        const crownCenterY = Math.floor(gridHeight * 0.25);\n        const crownRadius = Math.min(gridWidth / 2 - 1, gridHeight * 0.35);\n        \n        for (let y = 0; y < gridHeight - trunkHeight + 2; y++) {\n            for (let x = 0; x < gridWidth; x++) {\n                const dx = x - centerX;\n                const dy = y - crownCenterY;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                \n                // Create bumpy circular crown\n                const noise = this.noiseGenerator.perlin2D(x * 0.3, y * 0.3) * 2;\n                const adjustedRadius = crownRadius + noise;\n                \n                if (distance <= adjustedRadius) {\n                    // Add some holes for realistic look\n                    const holeNoise = this.noiseGenerator.perlin2D(x * 0.5, y * 0.5);\n                    if (holeNoise > -0.3) {\n                        ctx.fillStyle = colors.leaves;\n                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Jungle tree (tall with broad leaves)\n     */\n    drawJungleTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.6);\n        \n        // Draw tall trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 2; x <= centerX + 1; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw large palm-like leaves at top\n        const crownY = Math.floor(gridHeight * 0.1);\n        const crownHeight = Math.floor(gridHeight * 0.35);\n        \n        // Create multiple palm fronds\n        for (let frond = 0; frond < 6; frond++) {\n            const angle = (frond * Math.PI * 2) / 6;\n            const frondLength = Math.min(gridWidth / 2, gridHeight * 0.2);\n            \n            for (let i = 0; i < frondLength; i++) {\n                const x = centerX + Math.cos(angle) * i;\n                const y = crownY + crownHeight / 2 + Math.sin(angle) * i * 0.5;\n                \n                const gridX = Math.floor(x);\n                const gridY = Math.floor(y);\n                \n                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {\n                    ctx.fillStyle = colors.leaves;\n                    ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if pixel should be part of birch leaves\n     */\n    isBirchLeafPixel(relX, relY, gridWidth, crownHeight) {\n        // Oval shape for birch crown\n        const a = gridWidth * 0.3;\n        const b = crownHeight * 0.4;\n        return (relX * relX) / (a * a) + (relY * relY) / (b * b) <= 1;\n    }\n\n    /**\n     * Get color palette for tree type and season\n     */\n    getTreePalette(type) {\n        const season = this.options.season;\n        const baseColors = {\n            birch: {\n                trunkLight: '#F8F8F8', // White birch bark\n                trunkDark: '#404040',   // Black stripes\n                trunk: '#E8E8E8',\n                leaves: season === 'autumn' ? '#FFD700' : season === 'winter' ? '#F0F0F0' : '#90EE90'\n            },\n            fir: {\n                trunk: '#8B4513',\n                leaves: season === 'winter' ? '#0F5F0F' : '#228B22' // Darker green\n            },\n            oak: {\n                trunk: '#8B4513',\n                leaves: season === 'autumn' ? '#FF8C00' : season === 'winter' ? '#A0A0A0' : '#32CD32'\n            },\n            jungle: {\n                trunk: '#8B4513',\n                leaves: '#228B22' // Always green\n            }\n        };\n\n        return baseColors[type] || baseColors.oak;\n    }\n\n    /**\n     * Create a tree instance\n     */\n    createTree(config) {\n        const treeType = config.type || this.getRandomTreeType();\n        const baseSize = Math.min(this.canvas.width, this.canvas.height) * 0.15; // Smaller than clouds\n        \n        const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.8, 1.2)));\n        const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(1.5, 2.5)));\n\n        // Check cache\n        const cacheKey = `${treeType}_${width}_${height}_${this.options.season}`;\n        let treeCanvas = this.treeCache.get(cacheKey);\n\n        if (!treeCanvas) {\n            treeCanvas = this.generateTree(width, height, treeType);\n            this.treeCache.set(cacheKey, treeCanvas);\n\n            // Limit cache size\n            if (this.treeCache.size > 30) {\n                const firstKey = this.treeCache.keys().next().value;\n                this.treeCache.delete(firstKey);\n            }\n        }\n\n        return {\n            type: 'proceduralTree',\n            x: config.x || this.canvas.width,\n            y: config.y || this.canvas.height - height,\n            width: width,\n            height: height,\n            treeType: treeType,\n            treeCanvas: treeCanvas,\n            speed: config.speed || this.getRandomFloat(0.5, 1.2),\n            opacity: config.opacity || 1.0,\n            lastUpdateTime: Date.now(),\n\n            // Update method\n            update(deltaTime) {\n                // Trees move with the parallax\n                this.x -= this.speed;\n            },\n\n            // Render method\n            render(ctx) {\n                ctx.save();\n                ctx.globalAlpha = this.opacity;\n                ctx.drawImage(this.treeCanvas, this.x, this.y, this.width, this.height);\n                ctx.restore();\n            }\n        };\n    }\n\n    /**\n     * Get random tree type\n     */\n    getRandomTreeType() {\n        const types = this.options.treeTypes;\n        return types[Math.floor(Math.random() * types.length)];\n    }\n\n    /**\n     * Get random float between min and max\n     */\n    getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Update tree generation\n     */\n    update(deltaTime = 16) {\n        this.time += this.options.animationSpeed * deltaTime;\n    }\n\n    /**\n     * Set season and update tree colors\n     */\n    setSeason(season) {\n        this.options.season = season;\n        this.treeCache.clear(); // Regenerate with new season colors\n    }\n\n    /**\n     * Set time of day\n     */\n    setTimeOfDay(timeOfDay) {\n        this.options.timeOfDay = timeOfDay;\n        this.colorPalette.setTimeOfDay(timeOfDay);\n    }\n\n    /**\n     * Update configuration options\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n\n        if (newOptions.season) {\n            this.setSeason(newOptions.season);\n        }\n\n        if (newOptions.timeOfDay) {\n            this.setTimeOfDay(newOptions.timeOfDay);\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.treeCache.clear();\n    }\n}\n\nexport default TreeGenerator;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,OAAOC,YAAY,MAAM,0BAA0B;AAEnD,OAAO,MAAMC,aAAa,CAAC;EACvBC,WAAWA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAC9B,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,GAAG,GAAGF,MAAM,CAACG,UAAU,CAAC,IAAI,CAAC;IAClC,IAAI,CAACC,cAAc,GAAG,IAAIR,cAAc,CAACK,OAAO,CAACI,IAAI,IAAIC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC;IAC9E,IAAI,CAACC,YAAY,GAAG,IAAIX,YAAY,CAAC,CAAC;;IAEtC;IACA,IAAI,CAACI,OAAO,GAAG;MACXQ,SAAS,EAAER,OAAO,CAACQ,SAAS,IAAI,KAAK;MACrCC,SAAS,EAAET,OAAO,CAACS,SAAS,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK,CAAC;MACvDC,MAAM,EAAEV,OAAO,CAACU,MAAM,IAAI,QAAQ;MAClCC,SAAS,EAAEX,OAAO,CAACW,SAAS,IAAI,CAAC;MAAE;MACnCC,YAAY,EAAEZ,OAAO,CAACY,YAAY,IAAI,GAAG;MACzCC,cAAc,EAAEb,OAAO,CAACa,cAAc,IAAI,KAAK;MAC/C,GAAGb;IACP,CAAC;IAED,IAAI,CAACc,IAAI,GAAG,CAAC;IACb,IAAI,CAACC,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;;IAE1B;IACA,IAAI,CAACT,YAAY,CAACU,YAAY,CAAC,IAAI,CAACjB,OAAO,CAACQ,SAAS,CAAC;EAC1D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,YAAYA,CAACC,KAAK,EAAEC,MAAM,EAAEC,IAAI,GAAG,KAAK,EAAE;IACtC,MAAMC,eAAe,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IACxD,MAAMC,YAAY,GAAGH,eAAe,CAACpB,UAAU,CAAC,IAAI,CAAC;IACrDoB,eAAe,CAACH,KAAK,GAAGA,KAAK;IAC7BG,eAAe,CAACF,MAAM,GAAGA,MAAM;;IAE/B;IACA,MAAMM,UAAU,GAAG,IAAI,CAACC,cAAc,CAACN,IAAI,CAAC;;IAE5C;IACA,MAAMV,SAAS,GAAG,IAAI,CAACX,OAAO,CAACW,SAAS;IACxC,MAAMiB,SAAS,GAAGvB,IAAI,CAACwB,IAAI,CAACV,KAAK,GAAGR,SAAS,CAAC;IAC9C,MAAMmB,UAAU,GAAGzB,IAAI,CAACwB,IAAI,CAACT,MAAM,GAAGT,SAAS,CAAC;;IAEhD;IACA,QAAQU,IAAI;MACR,KAAK,OAAO;QACR,IAAI,CAACU,aAAa,CAACN,YAAY,EAAEG,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEe,UAAU,CAAC;QAC9E;MACJ,KAAK,KAAK;QACN,IAAI,CAACM,WAAW,CAACP,YAAY,EAAEG,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEe,UAAU,CAAC;QAC5E;MACJ,KAAK,KAAK;QACN,IAAI,CAACO,WAAW,CAACR,YAAY,EAAEG,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEe,UAAU,CAAC;QAC5E;MACJ,KAAK,QAAQ;QACT,IAAI,CAACQ,cAAc,CAACT,YAAY,EAAEG,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEe,UAAU,CAAC;QAC/E;MACJ;QACI,IAAI,CAACO,WAAW,CAACR,YAAY,EAAEG,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEe,UAAU,CAAC;IACpF;IAEA,OAAOJ,eAAe;EAC1B;;EAEA;AACJ;AACA;EACIS,aAAaA,CAAC9B,GAAG,EAAE2B,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEwB,MAAM,EAAE;IACzD,MAAMC,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACT,SAAS,GAAG,CAAC,CAAC;IACzC,MAAMU,WAAW,GAAGjC,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;;IAEhD;IACA,KAAK,IAAIS,CAAC,GAAGT,UAAU,GAAGQ,WAAW,EAAEC,CAAC,GAAGT,UAAU,EAAES,CAAC,EAAE,EAAE;MACxD,KAAK,IAAIC,CAAC,GAAGJ,OAAO,GAAG,CAAC,EAAEI,CAAC,IAAIJ,OAAO,EAAEI,CAAC,EAAE,EAAE;QACzC;QACA,MAAMC,QAAQ,GAAG,CAACF,CAAC,IAAIT,UAAU,GAAGQ,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;QAC3DrC,GAAG,CAACyC,SAAS,GAAGD,QAAQ,GAAGN,MAAM,CAACQ,SAAS,GAAGR,MAAM,CAACS,UAAU;QAC/D3C,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;MACpE;IACJ;;IAEA;IACA,MAAMmC,WAAW,GAAGzC,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;IAChD,MAAMiB,WAAW,GAAG1C,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;IAEhD,KAAK,IAAIS,CAAC,GAAGO,WAAW,EAAEP,CAAC,GAAGO,WAAW,GAAGC,WAAW,EAAER,CAAC,EAAE,EAAE;MAC1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,EAAEY,CAAC,EAAE,EAAE;QAChC,IAAI,IAAI,CAACQ,gBAAgB,CAACR,CAAC,GAAGJ,OAAO,EAAEG,CAAC,GAAGO,WAAW,EAAElB,SAAS,EAAEmB,WAAW,CAAC,EAAE;UAC7E9C,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACc,MAAM;UAC7BhD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;QACpE;MACJ;IACJ;EACJ;;EAEA;AACJ;AACA;EACIqB,WAAWA,CAAC/B,GAAG,EAAE2B,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEwB,MAAM,EAAE;IACvD,MAAMC,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACT,SAAS,GAAG,CAAC,CAAC;IACzC,MAAMU,WAAW,GAAGjC,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;;IAEhD;IACA,KAAK,IAAIS,CAAC,GAAGT,UAAU,GAAGQ,WAAW,EAAEC,CAAC,GAAGT,UAAU,EAAES,CAAC,EAAE,EAAE;MACxD,KAAK,IAAIC,CAAC,GAAGJ,OAAO,GAAG,CAAC,EAAEI,CAAC,IAAIJ,OAAO,EAAEI,CAAC,EAAE,EAAE;QACzCvC,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACe,KAAK;QAC5BjD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;MACpE;IACJ;;IAEA;IACA,MAAMwC,MAAM,GAAG,CAAC;IAChB,MAAMC,WAAW,GAAG/C,IAAI,CAACgC,KAAK,CAAC,CAACP,UAAU,GAAGQ,WAAW,IAAIa,MAAM,CAAC;IAEnE,KAAK,IAAIE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,MAAM,EAAEE,KAAK,EAAE,EAAE;MACzC,MAAMC,MAAM,GAAGD,KAAK,GAAGD,WAAW;MAClC,MAAMG,WAAW,GAAGD,MAAM,GAAGF,WAAW,GAAG,CAAC,CAAC,CAAC;MAC9C,MAAMI,QAAQ,GAAGnD,IAAI,CAACoD,GAAG,CAAC7B,SAAS,EAAE,CAACyB,KAAK,GAAG,CAAC,IAAI,CAAC,CAAC;MAErD,KAAK,IAAId,CAAC,GAAGe,MAAM,EAAEf,CAAC,GAAGgB,WAAW,IAAIhB,CAAC,GAAGT,UAAU,GAAGQ,WAAW,EAAEC,CAAC,EAAE,EAAE;QACvE,MAAMmB,QAAQ,GAAGrD,IAAI,CAACgC,KAAK,CAACmB,QAAQ,IAAIjB,CAAC,GAAGe,MAAM,GAAG,CAAC,CAAC,GAAGF,WAAW,CAAC;QACtE,MAAMO,MAAM,GAAGvB,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACqB,QAAQ,GAAG,CAAC,CAAC;QACjD,MAAME,IAAI,GAAGxB,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACqB,QAAQ,GAAG,CAAC,CAAC;QAE/C,KAAK,IAAIlB,CAAC,GAAGmB,MAAM,EAAEnB,CAAC,IAAIoB,IAAI,EAAEpB,CAAC,EAAE,EAAE;UACjC,IAAIA,CAAC,IAAI,CAAC,IAAIA,CAAC,GAAGZ,SAAS,EAAE;YACzB;YACA,MAAMiC,MAAM,GAAGrB,CAAC,KAAKmB,MAAM,IAAInB,CAAC,KAAKoB,IAAI;YACzC,IAAI,CAACC,MAAM,IAAIxD,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,EAAE;cAChCL,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACc,MAAM;cAC7BhD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;YACpE;UACJ;QACJ;MACJ;IACJ;EACJ;;EAEA;AACJ;AACA;EACIsB,WAAWA,CAAChC,GAAG,EAAE2B,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEwB,MAAM,EAAE;IACvD,MAAMC,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACT,SAAS,GAAG,CAAC,CAAC;IACzC,MAAMU,WAAW,GAAGjC,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;;IAEhD;IACA,KAAK,IAAIS,CAAC,GAAGT,UAAU,GAAGQ,WAAW,EAAEC,CAAC,GAAGT,UAAU,EAAES,CAAC,EAAE,EAAE;MACxD,KAAK,IAAIC,CAAC,GAAGJ,OAAO,GAAG,CAAC,EAAEI,CAAC,IAAIJ,OAAO,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;QAC7CvC,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACe,KAAK;QAC5BjD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;MACpE;IACJ;;IAEA;IACA,MAAMmD,YAAY,GAAGzD,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,IAAI,CAAC;IAClD,MAAMiC,WAAW,GAAG1D,IAAI,CAACoD,GAAG,CAAC7B,SAAS,GAAG,CAAC,GAAG,CAAC,EAAEE,UAAU,GAAG,IAAI,CAAC;IAElE,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,UAAU,GAAGQ,WAAW,GAAG,CAAC,EAAEC,CAAC,EAAE,EAAE;MACnD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,SAAS,EAAEY,CAAC,EAAE,EAAE;QAChC,MAAMwB,EAAE,GAAGxB,CAAC,GAAGJ,OAAO;QACtB,MAAM6B,EAAE,GAAG1B,CAAC,GAAGuB,YAAY;QAC3B,MAAMI,QAAQ,GAAG7D,IAAI,CAAC8D,IAAI,CAACH,EAAE,GAAGA,EAAE,GAAGC,EAAE,GAAGA,EAAE,CAAC;;QAE7C;QACA,MAAMG,KAAK,GAAG,IAAI,CAACjE,cAAc,CAACkE,QAAQ,CAAC7B,CAAC,GAAG,GAAG,EAAED,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC;QAChE,MAAM+B,cAAc,GAAGP,WAAW,GAAGK,KAAK;QAE1C,IAAIF,QAAQ,IAAII,cAAc,EAAE;UAC5B;UACA,MAAMC,SAAS,GAAG,IAAI,CAACpE,cAAc,CAACkE,QAAQ,CAAC7B,CAAC,GAAG,GAAG,EAAED,CAAC,GAAG,GAAG,CAAC;UAChE,IAAIgC,SAAS,GAAG,CAAC,GAAG,EAAE;YAClBtE,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACc,MAAM;YAC7BhD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;UACpE;QACJ;MACJ;IACJ;EACJ;;EAEA;AACJ;AACA;EACIuB,cAAcA,CAACjC,GAAG,EAAE2B,SAAS,EAAEE,UAAU,EAAEnB,SAAS,EAAEwB,MAAM,EAAE;IAC1D,MAAMC,OAAO,GAAG/B,IAAI,CAACgC,KAAK,CAACT,SAAS,GAAG,CAAC,CAAC;IACzC,MAAMU,WAAW,GAAGjC,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;;IAEhD;IACA,KAAK,IAAIS,CAAC,GAAGT,UAAU,GAAGQ,WAAW,EAAEC,CAAC,GAAGT,UAAU,EAAES,CAAC,EAAE,EAAE;MACxD,KAAK,IAAIC,CAAC,GAAGJ,OAAO,GAAG,CAAC,EAAEI,CAAC,IAAIJ,OAAO,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;QAC7CvC,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACe,KAAK;QAC5BjD,GAAG,CAAC4C,QAAQ,CAACL,CAAC,GAAG7B,SAAS,EAAE4B,CAAC,GAAG5B,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;MACpE;IACJ;;IAEA;IACA,MAAM6D,MAAM,GAAGnE,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,GAAG,CAAC;IAC3C,MAAMiB,WAAW,GAAG1C,IAAI,CAACgC,KAAK,CAACP,UAAU,GAAG,IAAI,CAAC;;IAEjD;IACA,KAAK,IAAI2C,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,EAAE,EAAE;MACpC,MAAMC,KAAK,GAAID,KAAK,GAAGpE,IAAI,CAACsE,EAAE,GAAG,CAAC,GAAI,CAAC;MACvC,MAAMC,WAAW,GAAGvE,IAAI,CAACoD,GAAG,CAAC7B,SAAS,GAAG,CAAC,EAAEE,UAAU,GAAG,GAAG,CAAC;MAE7D,KAAK,IAAI+C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,WAAW,EAAEC,CAAC,EAAE,EAAE;QAClC,MAAMrC,CAAC,GAAGJ,OAAO,GAAG/B,IAAI,CAACyE,GAAG,CAACJ,KAAK,CAAC,GAAGG,CAAC;QACvC,MAAMtC,CAAC,GAAGiC,MAAM,GAAGzB,WAAW,GAAG,CAAC,GAAG1C,IAAI,CAAC0E,GAAG,CAACL,KAAK,CAAC,GAAGG,CAAC,GAAG,GAAG;QAE9D,MAAMG,KAAK,GAAG3E,IAAI,CAACgC,KAAK,CAACG,CAAC,CAAC;QAC3B,MAAMyC,KAAK,GAAG5E,IAAI,CAACgC,KAAK,CAACE,CAAC,CAAC;QAE3B,IAAIyC,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGpD,SAAS,IAAIqD,KAAK,IAAI,CAAC,IAAIA,KAAK,GAAGnD,UAAU,EAAE;UACrE7B,GAAG,CAACyC,SAAS,GAAGP,MAAM,CAACc,MAAM;UAC7BhD,GAAG,CAAC4C,QAAQ,CAACmC,KAAK,GAAGrE,SAAS,EAAEsE,KAAK,GAAGtE,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;QAC5E;MACJ;IACJ;EACJ;;EAEA;AACJ;AACA;EACIqC,gBAAgBA,CAACkC,IAAI,EAAEC,IAAI,EAAEvD,SAAS,EAAEmB,WAAW,EAAE;IACjD;IACA,MAAMqC,CAAC,GAAGxD,SAAS,GAAG,GAAG;IACzB,MAAMyD,CAAC,GAAGtC,WAAW,GAAG,GAAG;IAC3B,OAAQmC,IAAI,GAAGA,IAAI,IAAKE,CAAC,GAAGA,CAAC,CAAC,GAAID,IAAI,GAAGA,IAAI,IAAKE,CAAC,GAAGA,CAAC,CAAC,IAAI,CAAC;EACjE;;EAEA;AACJ;AACA;EACI1D,cAAcA,CAACN,IAAI,EAAE;IACjB,MAAMX,MAAM,GAAG,IAAI,CAACV,OAAO,CAACU,MAAM;IAClC,MAAM4E,UAAU,GAAG;MACfC,KAAK,EAAE;QACH3C,UAAU,EAAE,SAAS;QAAE;QACvBD,SAAS,EAAE,SAAS;QAAI;QACxBO,KAAK,EAAE,SAAS;QAChBD,MAAM,EAAEvC,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAGA,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAG;MAChF,CAAC;MACD8E,GAAG,EAAE;QACDtC,KAAK,EAAE,SAAS;QAChBD,MAAM,EAAEvC,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAG,SAAS,CAAC;MACxD,CAAC;MACD+E,GAAG,EAAE;QACDvC,KAAK,EAAE,SAAS;QAChBD,MAAM,EAAEvC,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAGA,MAAM,KAAK,QAAQ,GAAG,SAAS,GAAG;MAChF,CAAC;MACDgF,MAAM,EAAE;QACJxC,KAAK,EAAE,SAAS;QAChBD,MAAM,EAAE,SAAS,CAAC;MACtB;IACJ,CAAC;IAED,OAAOqC,UAAU,CAACjE,IAAI,CAAC,IAAIiE,UAAU,CAACG,GAAG;EAC7C;;EAEA;AACJ;AACA;EACIE,UAAUA,CAACC,MAAM,EAAE;IACf,MAAMC,QAAQ,GAAGD,MAAM,CAACvE,IAAI,IAAI,IAAI,CAACyE,iBAAiB,CAAC,CAAC;IACxD,MAAMC,QAAQ,GAAG1F,IAAI,CAACoD,GAAG,CAAC,IAAI,CAAC1D,MAAM,CAACoB,KAAK,EAAE,IAAI,CAACpB,MAAM,CAACqB,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;;IAEzE,MAAMD,KAAK,GAAGd,IAAI,CAAC2F,KAAK,CAACD,QAAQ,IAAIH,MAAM,CAACK,eAAe,IAAI,IAAI,CAACC,cAAc,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;IAC9F,MAAM9E,MAAM,GAAGf,IAAI,CAAC2F,KAAK,CAACD,QAAQ,IAAIH,MAAM,CAACO,gBAAgB,IAAI,IAAI,CAACD,cAAc,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;;IAEhG;IACA,MAAME,QAAQ,GAAG,GAAGP,QAAQ,IAAI1E,KAAK,IAAIC,MAAM,IAAI,IAAI,CAACpB,OAAO,CAACU,MAAM,EAAE;IACxE,IAAI2F,UAAU,GAAG,IAAI,CAACtF,SAAS,CAACuF,GAAG,CAACF,QAAQ,CAAC;IAE7C,IAAI,CAACC,UAAU,EAAE;MACbA,UAAU,GAAG,IAAI,CAACnF,YAAY,CAACC,KAAK,EAAEC,MAAM,EAAEyE,QAAQ,CAAC;MACvD,IAAI,CAAC9E,SAAS,CAACwF,GAAG,CAACH,QAAQ,EAAEC,UAAU,CAAC;;MAExC;MACA,IAAI,IAAI,CAACtF,SAAS,CAACyF,IAAI,GAAG,EAAE,EAAE;QAC1B,MAAMC,QAAQ,GAAG,IAAI,CAAC1F,SAAS,CAAC2F,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACC,KAAK;QACnD,IAAI,CAAC7F,SAAS,CAAC8F,MAAM,CAACJ,QAAQ,CAAC;MACnC;IACJ;IAEA,OAAO;MACHpF,IAAI,EAAE,gBAAgB;MACtBmB,CAAC,EAAEoD,MAAM,CAACpD,CAAC,IAAI,IAAI,CAACzC,MAAM,CAACoB,KAAK;MAChCoB,CAAC,EAAEqD,MAAM,CAACrD,CAAC,IAAI,IAAI,CAACxC,MAAM,CAACqB,MAAM,GAAGA,MAAM;MAC1CD,KAAK,EAAEA,KAAK;MACZC,MAAM,EAAEA,MAAM;MACdyE,QAAQ,EAAEA,QAAQ;MAClBQ,UAAU,EAAEA,UAAU;MACtBS,KAAK,EAAElB,MAAM,CAACkB,KAAK,IAAI,IAAI,CAACZ,cAAc,CAAC,GAAG,EAAE,GAAG,CAAC;MACpDa,OAAO,EAAEnB,MAAM,CAACmB,OAAO,IAAI,GAAG;MAC9BC,cAAc,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MAE1B;MACAC,MAAMA,CAACC,SAAS,EAAE;QACd;QACA,IAAI,CAAC5E,CAAC,IAAI,IAAI,CAACsE,KAAK;MACxB,CAAC;MAED;MACAO,MAAMA,CAACpH,GAAG,EAAE;QACRA,GAAG,CAACqH,IAAI,CAAC,CAAC;QACVrH,GAAG,CAACsH,WAAW,GAAG,IAAI,CAACR,OAAO;QAC9B9G,GAAG,CAACuH,SAAS,CAAC,IAAI,CAACnB,UAAU,EAAE,IAAI,CAAC7D,CAAC,EAAE,IAAI,CAACD,CAAC,EAAE,IAAI,CAACpB,KAAK,EAAE,IAAI,CAACC,MAAM,CAAC;QACvEnB,GAAG,CAACwH,OAAO,CAAC,CAAC;MACjB;IACJ,CAAC;EACL;;EAEA;AACJ;AACA;EACI3B,iBAAiBA,CAAA,EAAG;IAChB,MAAM4B,KAAK,GAAG,IAAI,CAAC1H,OAAO,CAACS,SAAS;IACpC,OAAOiH,KAAK,CAACrH,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAGoH,KAAK,CAACC,MAAM,CAAC,CAAC;EAC1D;;EAEA;AACJ;AACA;EACIzB,cAAcA,CAACzC,GAAG,EAAEmE,GAAG,EAAE;IACrB,OAAOvH,IAAI,CAACC,MAAM,CAAC,CAAC,IAAIsH,GAAG,GAAGnE,GAAG,CAAC,GAAGA,GAAG;EAC5C;;EAEA;AACJ;AACA;EACI0D,MAAMA,CAACC,SAAS,GAAG,EAAE,EAAE;IACnB,IAAI,CAACtG,IAAI,IAAI,IAAI,CAACd,OAAO,CAACa,cAAc,GAAGuG,SAAS;EACxD;;EAEA;AACJ;AACA;EACIS,SAASA,CAACnH,MAAM,EAAE;IACd,IAAI,CAACV,OAAO,CAACU,MAAM,GAAGA,MAAM;IAC5B,IAAI,CAACK,SAAS,CAAC+G,KAAK,CAAC,CAAC,CAAC,CAAC;EAC5B;;EAEA;AACJ;AACA;EACI7G,YAAYA,CAACT,SAAS,EAAE;IACpB,IAAI,CAACR,OAAO,CAACQ,SAAS,GAAGA,SAAS;IAClC,IAAI,CAACD,YAAY,CAACU,YAAY,CAACT,SAAS,CAAC;EAC7C;;EAEA;AACJ;AACA;EACIuH,aAAaA,CAACC,UAAU,EAAE;IACtB,IAAI,CAAChI,OAAO,GAAG;MAAE,GAAG,IAAI,CAACA,OAAO;MAAE,GAAGgI;IAAW,CAAC;IAEjD,IAAIA,UAAU,CAACtH,MAAM,EAAE;MACnB,IAAI,CAACmH,SAAS,CAACG,UAAU,CAACtH,MAAM,CAAC;IACrC;IAEA,IAAIsH,UAAU,CAACxH,SAAS,EAAE;MACtB,IAAI,CAACS,YAAY,CAAC+G,UAAU,CAACxH,SAAS,CAAC;IAC3C;EACJ;;EAEA;AACJ;AACA;EACIyH,OAAOA,CAAA,EAAG;IACN,IAAI,CAAClH,SAAS,CAAC+G,KAAK,CAAC,CAAC;EAC1B;AACJ;AAEA,eAAejI,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}