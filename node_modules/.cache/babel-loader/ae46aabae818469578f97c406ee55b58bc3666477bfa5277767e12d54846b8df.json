{"ast":null,"code":"/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\nexport class CloudGenerator {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n    this.colorPalette = new ColorPalette();\n\n    // Configuration options\n    this.options = {\n      timeOfDay: options.timeOfDay || 'day',\n      cloudTypes: options.cloudTypes || ['cumulus'],\n      density: options.density || 0.3,\n      size: options.size || 1.0,\n      opacity: options.opacity || 0.8,\n      speed: options.speed || 0.2,\n      noiseScale: options.noiseScale || 0.005,\n      animationSpeed: options.animationSpeed || 0.001,\n      updateInterval: options.updateInterval || 15000,\n      // Update every 15 seconds\n      ...options\n    };\n    this.time = 0;\n    this.lastUpdateTime = 0;\n    this.cloudCache = new Map();\n\n    // Initialize color palette\n    this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n  }\n\n  /**\n   * Generate a single cloud shape using noise with 8-bit pixel art style\n   * @param {number} width - Cloud width\n   * @param {number} height - Cloud height\n   * @param {string} type - Cloud type ('cumulus', 'stratus', 'cirrus')\n   * @returns {ImageData} Generated cloud image data\n   */\n  generateCloudShape(width, height, type = 'cumulus') {\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n\n    // 8-bit style pixel grid size\n    const pixelSize = 8; // Each \"pixel\" is 8x8 actual pixels\n    const gridWidth = Math.ceil(width / pixelSize);\n    const gridHeight = Math.ceil(height / pixelSize);\n    const palette = this.colorPalette.getCurrentPalette();\n    const cloudParams = this.getCloudParameters(type);\n\n    // Create 8-bit color palette for clouds\n    const cloudColors = this.create8BitCloudPalette(palette);\n\n    // Generate cloud on pixel grid\n    for (let gridY = 0; gridY < gridHeight; gridY++) {\n      for (let gridX = 0; gridX < gridWidth; gridX++) {\n        // Sample noise at grid center\n        const sampleX = (gridX + 0.5) * pixelSize;\n        const sampleY = (gridY + 0.5) * pixelSize;\n\n        // Generate noise value for cloud density\n        const noise1 = this.noiseGenerator.octaveNoise2D(sampleX * cloudParams.scale1 + this.time, sampleY * cloudParams.scale1, cloudParams.octaves1, cloudParams.persistence1);\n        const noise2 = this.noiseGenerator.octaveNoise2D(sampleX * cloudParams.scale2 + this.time * 0.5, sampleY * cloudParams.scale2, cloudParams.octaves2, cloudParams.persistence2);\n\n        // Combine noise values\n        let density = (noise1 + noise2 * 0.5) * 0.5 + 0.5;\n\n        // Apply cloud shape falloff\n        const centerX = gridWidth / 2;\n        const centerY = gridHeight / 2;\n        const distanceFromCenter = Math.sqrt(Math.pow((gridX - centerX) / gridWidth, 2) + Math.pow((gridY - centerY) / gridHeight, 2));\n        const falloff = Math.max(0, 1 - distanceFromCenter * cloudParams.falloffStrength);\n        density *= falloff;\n\n        // Apply threshold and quantize density to 8-bit levels\n        density = Math.max(0, density - cloudParams.threshold);\n        density = Math.min(1, density * cloudParams.contrast);\n\n        // Quantize density to 4 levels for 8-bit look\n        const quantizedDensity = Math.floor(density * 4) / 4;\n        if (quantizedDensity > 0) {\n          // Choose color from 8-bit palette based on density\n          const colorIndex = Math.min(cloudColors.length - 1, Math.floor(quantizedDensity * cloudColors.length));\n          const color = cloudColors[colorIndex];\n\n          // Draw pixel block\n          offscreenCtx.fillStyle = color;\n          offscreenCtx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n    return offscreenCanvas;\n  }\n\n  /**\n   * Create 8-bit style color palette for clouds\n   * @param {Object} palette - Base color palette\n   * @returns {Array} Array of color strings\n   */\n  create8BitCloudPalette(palette) {\n    const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n    const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n\n    // Create 4-color palette for 8-bit look\n    const colors = [];\n    for (let i = 0; i < 4; i++) {\n      const factor = i / 3;\n      const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * factor);\n      const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * factor);\n      const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * factor);\n\n      // Quantize colors to 8-bit levels (reduce color depth)\n      const quantizedR = Math.floor(r / 32) * 32;\n      const quantizedG = Math.floor(g / 32) * 32;\n      const quantizedB = Math.floor(b / 32) * 32;\n      colors.push(`rgba(${quantizedR}, ${quantizedG}, ${quantizedB}, ${this.options.opacity})`);\n    }\n    return colors;\n  }\n\n  /**\n   * Get cloud parameters based on cloud type\n   * @param {string} type - Cloud type\n   * @returns {Object} Cloud generation parameters\n   */\n  getCloudParameters(type) {\n    const params = {\n      cumulus: {\n        scale1: 0.02,\n        // Larger scale for chunkier pixels\n        scale2: 0.05,\n        octaves1: 2,\n        // Fewer octaves for simpler patterns\n        octaves2: 1,\n        persistence1: 0.8,\n        persistence2: 0.5,\n        falloffStrength: 1.2,\n        threshold: 0.3,\n        contrast: 2.5\n      },\n      stratus: {\n        scale1: 0.01,\n        scale2: 0.03,\n        octaves1: 3,\n        octaves2: 1,\n        persistence1: 0.7,\n        persistence2: 0.6,\n        falloffStrength: 0.6,\n        threshold: 0.2,\n        contrast: 2.0\n      },\n      cirrus: {\n        scale1: 0.03,\n        scale2: 0.08,\n        octaves1: 2,\n        octaves2: 1,\n        persistence1: 0.9,\n        persistence2: 0.4,\n        falloffStrength: 1.8,\n        threshold: 0.4,\n        contrast: 3.5\n      }\n    };\n    return params[type] || params.cumulus;\n  }\n\n  /**\n   * Create a cloud instance\n   * @param {Object} config - Cloud configuration\n   * @returns {Object} Cloud object\n   */\n  createCloud(config) {\n    const cloudType = config.type || this.getRandomCloudType();\n    const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n    const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n    const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n    // Check cache for similar cloud\n    const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n    let cloudCanvas = this.cloudCache.get(cacheKey);\n    if (!cloudCanvas) {\n      cloudCanvas = this.generateCloudShape(width, height, cloudType);\n      this.cloudCache.set(cacheKey, cloudCanvas);\n\n      // Limit cache size\n      if (this.cloudCache.size > 20) {\n        const firstKey = this.cloudCache.keys().next().value;\n        this.cloudCache.delete(firstKey);\n      }\n    }\n    return {\n      type: 'proceduralCloud',\n      x: config.x || this.canvas.width,\n      y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n      width: width,\n      height: height,\n      cloudType: cloudType,\n      cloudCanvas: cloudCanvas,\n      speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n      opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n      lastUpdateTime: Date.now(),\n      // Update method\n      update(deltaTime) {\n        // Clouds don't need frequent updates, just movement\n        this.x -= this.speed;\n      },\n      // Render method\n      render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n        ctx.restore();\n      }\n    };\n  }\n\n  /**\n   * Get random cloud type based on configured types\n   * @returns {string} Cloud type\n   */\n  getRandomCloudType() {\n    const types = this.options.cloudTypes;\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get random float between min and max\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @returns {number} Random float\n   */\n  getRandomFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  /**\n   * Update cloud generation\n   * @param {number} deltaTime - Time since last update\n   */\n  update(deltaTime = 16) {\n    this.time += this.options.animationSpeed * deltaTime;\n  }\n\n  /**\n   * Set time of day and update cloud colors\n   * @param {string} timeOfDay - New time of day\n   */\n  setTimeOfDay(timeOfDay) {\n    this.options.timeOfDay = timeOfDay;\n    this.colorPalette.setTimeOfDay(timeOfDay);\n    // Clear cache to regenerate clouds with new colors\n    this.cloudCache.clear();\n  }\n\n  /**\n   * Update configuration options\n   * @param {Object} newOptions - New options to apply\n   */\n  updateOptions(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    if (newOptions.timeOfDay) {\n      this.setTimeOfDay(newOptions.timeOfDay);\n    }\n    if (newOptions.seed) {\n      this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n      this.cloudCache.clear();\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.cloudCache.clear();\n  }\n}\nexport default CloudGenerator;","map":{"version":3,"names":["NoiseGenerator","ColorPalette","CloudGenerator","constructor","canvas","options","ctx","getContext","noiseGenerator","seed","Math","random","colorPalette","timeOfDay","cloudTypes","density","size","opacity","speed","noiseScale","animationSpeed","updateInterval","time","lastUpdateTime","cloudCache","Map","setTimeOfDay","generateCloudShape","width","height","type","offscreenCanvas","document","createElement","offscreenCtx","pixelSize","gridWidth","ceil","gridHeight","palette","getCurrentPalette","cloudParams","getCloudParameters","cloudColors","create8BitCloudPalette","gridY","gridX","sampleX","sampleY","noise1","octaveNoise2D","scale1","octaves1","persistence1","noise2","scale2","octaves2","persistence2","centerX","centerY","distanceFromCenter","sqrt","pow","falloff","max","falloffStrength","threshold","min","contrast","quantizedDensity","floor","colorIndex","length","color","fillStyle","fillRect","baseColor","hexToRgb","cloudBase","highlightColor","cloudHighlight","colors","i","factor","r","round","g","b","quantizedR","quantizedG","quantizedB","push","params","cumulus","stratus","cirrus","createCloud","config","cloudType","getRandomCloudType","baseSize","widthMultiplier","getRandomFloat","heightMultiplier","cacheKey","cloudCanvas","get","set","firstKey","keys","next","value","delete","x","y","Date","now","update","deltaTime","render","save","globalAlpha","drawImage","restore","types","clear","updateOptions","newOptions","destroy"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/graphics/generators/CloudGenerator.js"],"sourcesContent":["/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\n\nexport class CloudGenerator {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n        this.colorPalette = new ColorPalette();\n\n        // Configuration options\n        this.options = {\n            timeOfDay: options.timeOfDay || 'day',\n            cloudTypes: options.cloudTypes || ['cumulus'],\n            density: options.density || 0.3,\n            size: options.size || 1.0,\n            opacity: options.opacity || 0.8,\n            speed: options.speed || 0.2,\n            noiseScale: options.noiseScale || 0.005,\n            animationSpeed: options.animationSpeed || 0.001,\n            updateInterval: options.updateInterval || 15000, // Update every 15 seconds\n            ...options\n        };\n\n        this.time = 0;\n        this.lastUpdateTime = 0;\n        this.cloudCache = new Map();\n\n        // Initialize color palette\n        this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n    }\n\n    /**\n     * Generate a single cloud shape using noise with 8-bit pixel art style\n     * @param {number} width - Cloud width\n     * @param {number} height - Cloud height\n     * @param {string} type - Cloud type ('cumulus', 'stratus', 'cirrus')\n     * @returns {ImageData} Generated cloud image data\n     */\n    generateCloudShape(width, height, type = 'cumulus') {\n        const offscreenCanvas = document.createElement('canvas');\n        const offscreenCtx = offscreenCanvas.getContext('2d');\n        offscreenCanvas.width = width;\n        offscreenCanvas.height = height;\n\n        // 8-bit style pixel grid size\n        const pixelSize = 8; // Each \"pixel\" is 8x8 actual pixels\n        const gridWidth = Math.ceil(width / pixelSize);\n        const gridHeight = Math.ceil(height / pixelSize);\n\n        const palette = this.colorPalette.getCurrentPalette();\n        const cloudParams = this.getCloudParameters(type);\n\n        // Create 8-bit color palette for clouds\n        const cloudColors = this.create8BitCloudPalette(palette);\n\n        // Generate cloud on pixel grid\n        for (let gridY = 0; gridY < gridHeight; gridY++) {\n            for (let gridX = 0; gridX < gridWidth; gridX++) {\n                // Sample noise at grid center\n                const sampleX = (gridX + 0.5) * pixelSize;\n                const sampleY = (gridY + 0.5) * pixelSize;\n\n                // Generate noise value for cloud density\n                const noise1 = this.noiseGenerator.octaveNoise2D(\n                    sampleX * cloudParams.scale1 + this.time,\n                    sampleY * cloudParams.scale1,\n                    cloudParams.octaves1,\n                    cloudParams.persistence1\n                );\n\n                const noise2 = this.noiseGenerator.octaveNoise2D(\n                    sampleX * cloudParams.scale2 + this.time * 0.5,\n                    sampleY * cloudParams.scale2,\n                    cloudParams.octaves2,\n                    cloudParams.persistence2\n                );\n\n                // Combine noise values\n                let density = (noise1 + noise2 * 0.5) * 0.5 + 0.5;\n\n                // Apply cloud shape falloff\n                const centerX = gridWidth / 2;\n                const centerY = gridHeight / 2;\n                const distanceFromCenter = Math.sqrt(\n                    Math.pow((gridX - centerX) / gridWidth, 2) +\n                    Math.pow((gridY - centerY) / gridHeight, 2)\n                );\n\n                const falloff = Math.max(0, 1 - distanceFromCenter * cloudParams.falloffStrength);\n                density *= falloff;\n\n                // Apply threshold and quantize density to 8-bit levels\n                density = Math.max(0, density - cloudParams.threshold);\n                density = Math.min(1, density * cloudParams.contrast);\n\n                // Quantize density to 4 levels for 8-bit look\n                const quantizedDensity = Math.floor(density * 4) / 4;\n\n                if (quantizedDensity > 0) {\n                    // Choose color from 8-bit palette based on density\n                    const colorIndex = Math.min(cloudColors.length - 1, Math.floor(quantizedDensity * cloudColors.length));\n                    const color = cloudColors[colorIndex];\n\n                    // Draw pixel block\n                    offscreenCtx.fillStyle = color;\n                    offscreenCtx.fillRect(\n                        gridX * pixelSize,\n                        gridY * pixelSize,\n                        pixelSize,\n                        pixelSize\n                    );\n                }\n            }\n        }\n\n        return offscreenCanvas;\n    }\n\n    /**\n     * Create 8-bit style color palette for clouds\n     * @param {Object} palette - Base color palette\n     * @returns {Array} Array of color strings\n     */\n    create8BitCloudPalette(palette) {\n        const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n        const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n\n        // Create 4-color palette for 8-bit look\n        const colors = [];\n        for (let i = 0; i < 4; i++) {\n            const factor = i / 3;\n            const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * factor);\n            const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * factor);\n            const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * factor);\n\n            // Quantize colors to 8-bit levels (reduce color depth)\n            const quantizedR = Math.floor(r / 32) * 32;\n            const quantizedG = Math.floor(g / 32) * 32;\n            const quantizedB = Math.floor(b / 32) * 32;\n\n            colors.push(`rgba(${quantizedR}, ${quantizedG}, ${quantizedB}, ${this.options.opacity})`);\n        }\n\n        return colors;\n    }\n\n    /**\n     * Get cloud parameters based on cloud type\n     * @param {string} type - Cloud type\n     * @returns {Object} Cloud generation parameters\n     */    getCloudParameters(type) {\n        const params = {\n            cumulus: {\n                scale1: 0.02,   // Larger scale for chunkier pixels\n                scale2: 0.05,\n                octaves1: 2,    // Fewer octaves for simpler patterns\n                octaves2: 1,\n                persistence1: 0.8,\n                persistence2: 0.5,\n                falloffStrength: 1.2,\n                threshold: 0.3,\n                contrast: 2.5\n            },\n            stratus: {\n                scale1: 0.01,\n                scale2: 0.03,\n                octaves1: 3,\n                octaves2: 1,\n                persistence1: 0.7,\n                persistence2: 0.6,\n                falloffStrength: 0.6,\n                threshold: 0.2,\n                contrast: 2.0\n            },\n            cirrus: {\n                scale1: 0.03,\n                scale2: 0.08,\n                octaves1: 2,\n                octaves2: 1,\n                persistence1: 0.9,\n                persistence2: 0.4,\n                falloffStrength: 1.8,\n                threshold: 0.4,\n                contrast: 3.5\n            }\n        };\n\n        return params[type] || params.cumulus;\n    }\n\n    /**\n     * Create a cloud instance\n     * @param {Object} config - Cloud configuration\n     * @returns {Object} Cloud object\n     */\n    createCloud(config) {\n        const cloudType = config.type || this.getRandomCloudType();\n        const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n\n        const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n        const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n        // Check cache for similar cloud\n        const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n        let cloudCanvas = this.cloudCache.get(cacheKey);\n\n        if (!cloudCanvas) {\n            cloudCanvas = this.generateCloudShape(width, height, cloudType);\n            this.cloudCache.set(cacheKey, cloudCanvas);\n\n            // Limit cache size\n            if (this.cloudCache.size > 20) {\n                const firstKey = this.cloudCache.keys().next().value;\n                this.cloudCache.delete(firstKey);\n            }\n        }\n\n        return {\n            type: 'proceduralCloud',\n            x: config.x || this.canvas.width,\n            y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n            width: width,\n            height: height,\n            cloudType: cloudType,\n            cloudCanvas: cloudCanvas,\n            speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n            opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n            lastUpdateTime: Date.now(),\n\n            // Update method\n            update(deltaTime) {\n                // Clouds don't need frequent updates, just movement\n                this.x -= this.speed;\n            },\n\n            // Render method\n            render(ctx) {\n                ctx.save();\n                ctx.globalAlpha = this.opacity;\n                ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n                ctx.restore();\n            }\n        };\n    }\n\n    /**\n     * Get random cloud type based on configured types\n     * @returns {string} Cloud type\n     */\n    getRandomCloudType() {\n        const types = this.options.cloudTypes;\n        return types[Math.floor(Math.random() * types.length)];\n    }\n\n    /**\n     * Get random float between min and max\n     * @param {number} min - Minimum value\n     * @param {number} max - Maximum value\n     * @returns {number} Random float\n     */\n    getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Update cloud generation\n     * @param {number} deltaTime - Time since last update\n     */\n    update(deltaTime = 16) {\n        this.time += this.options.animationSpeed * deltaTime;\n    }\n\n    /**\n     * Set time of day and update cloud colors\n     * @param {string} timeOfDay - New time of day\n     */\n    setTimeOfDay(timeOfDay) {\n        this.options.timeOfDay = timeOfDay;\n        this.colorPalette.setTimeOfDay(timeOfDay);\n        // Clear cache to regenerate clouds with new colors\n        this.cloudCache.clear();\n    }\n\n    /**\n     * Update configuration options\n     * @param {Object} newOptions - New options to apply\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n\n        if (newOptions.timeOfDay) {\n            this.setTimeOfDay(newOptions.timeOfDay);\n        }\n\n        if (newOptions.seed) {\n            this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n            this.cloudCache.clear();\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.cloudCache.clear();\n    }\n}\n\nexport default CloudGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}