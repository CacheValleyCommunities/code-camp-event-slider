{"ast":null,"code":"/**\n * Procedural Tree Generator\n * Creates pixel-perfect trees using L-system and fractal algorithms\n * Supports multiple tree types with Mario-style pixel art aesthetic\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\nexport class TreeGenerator {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n    this.colorPalette = new ColorPalette();\n\n    // Configuration options\n    this.options = {\n      timeOfDay: options.timeOfDay || 'day',\n      treeTypes: options.treeTypes || ['birch', 'fir', 'oak'],\n      season: options.season || 'summer',\n      pixelSize: options.pixelSize || 8,\n      // 8x8 pixel blocks for retro feel\n      windStrength: options.windStrength || 0.1,\n      animationSpeed: options.animationSpeed || 0.001,\n      ...options\n    };\n    this.time = 0;\n    this.treeCache = new Map();\n\n    // Initialize color palette\n    this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n  } /**\n    * Generate a tree using pixel art style\n    * @param {number} width - Tree width\n    * @param {number} height - Tree height\n    * @param {string} type - Tree type\n    * @returns {Canvas} Generated tree canvas\n    */\n  generateTree(width, height, type = 'oak') {\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n\n    // Clear canvas with transparent background\n    offscreenCtx.clearRect(0, 0, width, height);\n\n    // Get tree colors based on type and season\n    const treeColors = this.getTreePalette(type);\n\n    // Grid-based drawing for pixel art style\n    const pixelSize = this.options.pixelSize;\n    const gridWidth = Math.ceil(width / pixelSize);\n    const gridHeight = Math.ceil(height / pixelSize);\n    console.log(`Generating ${type} tree: ${width}x${height}, grid: ${gridWidth}x${gridHeight}`);\n\n    // Draw tree based on type\n    try {\n      switch (type) {\n        case 'birch':\n          this.drawBirchTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n          break;\n        case 'fir':\n          this.drawFirTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n          break;\n        case 'oak':\n          this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n          break;\n        case 'jungle':\n          this.drawJungleTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n          break;\n        default:\n          this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n      }\n    } catch (error) {\n      console.error(`Error drawing ${type} tree:`, error);\n      // Draw a simple fallback tree\n      offscreenCtx.fillStyle = '#8B4513';\n      offscreenCtx.fillRect(width / 2 - 5, height / 2, 10, height / 2);\n      offscreenCtx.fillStyle = '#228B22';\n      offscreenCtx.fillRect(width / 2 - 15, 0, 30, height / 2);\n    }\n    return offscreenCanvas;\n  }\n\n  /**\n   * Draw a Mario-style Birch tree\n   */\n  drawBirchTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.7);\n\n    // Draw trunk (white with black stripes for birch)\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX; x++) {\n        // Birch bark pattern - white with horizontal black stripes\n        const isStripe = (y - (gridHeight - trunkHeight)) % 4 === 0;\n        ctx.fillStyle = isStripe ? colors.trunkDark : colors.trunkLight;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw leaves (small, delicate crown)\n    const crownStartY = Math.floor(gridHeight * 0.2);\n    const crownHeight = Math.floor(gridHeight * 0.5);\n    for (let y = crownStartY; y < crownStartY + crownHeight; y++) {\n      for (let x = 0; x < gridWidth; x++) {\n        if (this.isBirchLeafPixel(x - centerX, y - crownStartY, gridWidth, crownHeight)) {\n          ctx.fillStyle = colors.leaves;\n          ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Fir tree (Christmas tree shape)\n   */\n  drawFirTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.2);\n\n    // Draw trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw triangular fir shape in layers\n    const layers = 4;\n    const layerHeight = Math.floor((gridHeight - trunkHeight) / layers);\n    for (let layer = 0; layer < layers; layer++) {\n      const layerY = layer * layerHeight;\n      const layerBottom = layerY + layerHeight + 2; // Overlap layers\n      const maxWidth = Math.min(gridWidth, (layer + 2) * 3);\n      for (let y = layerY; y < layerBottom && y < gridHeight - trunkHeight; y++) {\n        const widthAtY = Math.floor(maxWidth * (y - layerY + 1) / layerHeight);\n        const startX = centerX - Math.floor(widthAtY / 2);\n        const endX = centerX + Math.floor(widthAtY / 2);\n        for (let x = startX; x <= endX; x++) {\n          if (x >= 0 && x < gridWidth) {\n            // Add some randomness to edges for organic feel\n            const isEdge = x === startX || x === endX;\n            if (!isEdge || Math.random() > 0.3) {\n              ctx.fillStyle = colors.leaves;\n              ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Oak tree (round crown)\n   */\n  drawOakTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.4);\n\n    // Draw trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 1; x <= centerX + 1; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw round crown\n    const crownCenterY = Math.floor(gridHeight * 0.25);\n    const crownRadius = Math.min(gridWidth / 2 - 1, gridHeight * 0.35);\n    for (let y = 0; y < gridHeight - trunkHeight + 2; y++) {\n      for (let x = 0; x < gridWidth; x++) {\n        const dx = x - centerX;\n        const dy = y - crownCenterY;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Create bumpy circular crown\n        const noise = this.noiseGenerator.perlin2D(x * 0.3, y * 0.3) * 2;\n        const adjustedRadius = crownRadius + noise;\n        if (distance <= adjustedRadius) {\n          // Add some holes for realistic look\n          const holeNoise = this.noiseGenerator.perlin2D(x * 0.5, y * 0.5);\n          if (holeNoise > -0.3) {\n            ctx.fillStyle = colors.leaves;\n            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Draw a Mario-style Jungle tree (tall with broad leaves)\n   */\n  drawJungleTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n    const centerX = Math.floor(gridWidth / 2);\n    const trunkHeight = Math.floor(gridHeight * 0.6);\n\n    // Draw tall trunk\n    for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n      for (let x = centerX - 2; x <= centerX + 1; x++) {\n        ctx.fillStyle = colors.trunk;\n        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n      }\n    }\n\n    // Draw large palm-like leaves at top\n    const crownY = Math.floor(gridHeight * 0.1);\n    const crownHeight = Math.floor(gridHeight * 0.35);\n\n    // Create multiple palm fronds\n    for (let frond = 0; frond < 6; frond++) {\n      const angle = frond * Math.PI * 2 / 6;\n      const frondLength = Math.min(gridWidth / 2, gridHeight * 0.2);\n      for (let i = 0; i < frondLength; i++) {\n        const x = centerX + Math.cos(angle) * i;\n        const y = crownY + crownHeight / 2 + Math.sin(angle) * i * 0.5;\n        const gridX = Math.floor(x);\n        const gridY = Math.floor(y);\n        if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {\n          ctx.fillStyle = colors.leaves;\n          ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if pixel should be part of birch leaves\n   */\n  isBirchLeafPixel(relX, relY, gridWidth, crownHeight) {\n    // Oval shape for birch crown\n    const a = gridWidth * 0.3;\n    const b = crownHeight * 0.4;\n    return relX * relX / (a * a) + relY * relY / (b * b) <= 1;\n  }\n\n  /**\n   * Get color palette for tree type and season\n   */\n  getTreePalette(type) {\n    const season = this.options.season;\n    const baseColors = {\n      birch: {\n        trunkLight: '#F8F8F8',\n        // White birch bark\n        trunkDark: '#404040',\n        // Black stripes\n        trunk: '#E8E8E8',\n        leaves: season === 'autumn' ? '#FFD700' : season === 'winter' ? '#F0F0F0' : '#90EE90'\n      },\n      fir: {\n        trunk: '#8B4513',\n        leaves: season === 'winter' ? '#0F5F0F' : '#228B22' // Darker green\n      },\n      oak: {\n        trunk: '#8B4513',\n        leaves: season === 'autumn' ? '#FF8C00' : season === 'winter' ? '#A0A0A0' : '#32CD32'\n      },\n      jungle: {\n        trunk: '#8B4513',\n        leaves: '#228B22' // Always green\n      }\n    };\n    return baseColors[type] || baseColors.oak;\n  }\n\n  /**\n   * Create a tree instance\n   */\n  createTree(config) {\n    const treeType = config.type || this.getRandomTreeType();\n    const baseSize = Math.min(this.canvas.width, this.canvas.height) * 0.15; // Smaller than clouds\n\n    const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.8, 1.2)));\n    const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(1.5, 2.5)));\n\n    // Check cache\n    const cacheKey = `${treeType}_${width}_${height}_${this.options.season}`;\n    let treeCanvas = this.treeCache.get(cacheKey);\n    if (!treeCanvas) {\n      treeCanvas = this.generateTree(width, height, treeType);\n      this.treeCache.set(cacheKey, treeCanvas);\n\n      // Limit cache size\n      if (this.treeCache.size > 30) {\n        const firstKey = this.treeCache.keys().next().value;\n        this.treeCache.delete(firstKey);\n      }\n    }\n    return {\n      type: 'proceduralTree',\n      x: config.x || this.canvas.width,\n      y: config.y || this.canvas.height - height,\n      width: width,\n      height: height,\n      treeType: treeType,\n      treeCanvas: treeCanvas,\n      speed: config.speed || this.getRandomFloat(0.5, 1.2),\n      opacity: config.opacity || 1.0,\n      lastUpdateTime: Date.now(),\n      // Update method\n      update(deltaTime) {\n        // Trees move with the parallax\n        this.x -= this.speed;\n      },\n      // Render method\n      render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        ctx.drawImage(this.treeCanvas, this.x, this.y, this.width, this.height);\n        ctx.restore();\n      }\n    };\n  }\n\n  /**\n   * Get random tree type\n   */\n  getRandomTreeType() {\n    const types = this.options.treeTypes;\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get random float between min and max\n   */\n  getRandomFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  /**\n   * Update tree generation\n   */\n  update(deltaTime = 16) {\n    this.time += this.options.animationSpeed * deltaTime;\n  }\n\n  /**\n   * Set season and update tree colors\n   */\n  setSeason(season) {\n    this.options.season = season;\n    this.treeCache.clear(); // Regenerate with new season colors\n  }\n\n  /**\n   * Set time of day\n   */\n  setTimeOfDay(timeOfDay) {\n    this.options.timeOfDay = timeOfDay;\n    this.colorPalette.setTimeOfDay(timeOfDay);\n  }\n\n  /**\n   * Update configuration options\n   */\n  updateOptions(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    if (newOptions.season) {\n      this.setSeason(newOptions.season);\n    }\n    if (newOptions.timeOfDay) {\n      this.setTimeOfDay(newOptions.timeOfDay);\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.treeCache.clear();\n  }\n}\nexport default TreeGenerator;","map":{"version":3,"names":["NoiseGenerator","ColorPalette","TreeGenerator","constructor","canvas","options","ctx","getContext","noiseGenerator","seed","Math","random","colorPalette","timeOfDay","treeTypes","season","pixelSize","windStrength","animationSpeed","time","treeCache","Map","setTimeOfDay","generateTree","width","height","type","offscreenCanvas","document","createElement","offscreenCtx","clearRect","treeColors","getTreePalette","gridWidth","ceil","gridHeight","console","log","drawBirchTree","drawFirTree","drawOakTree","drawJungleTree","error","fillStyle","fillRect","colors","centerX","floor","trunkHeight","y","x","isStripe","trunkDark","trunkLight","crownStartY","crownHeight","isBirchLeafPixel","leaves","trunk","layers","layerHeight","layer","layerY","layerBottom","maxWidth","min","widthAtY","startX","endX","isEdge","crownCenterY","crownRadius","dx","dy","distance","sqrt","noise","perlin2D","adjustedRadius","holeNoise","crownY","frond","angle","PI","frondLength","i","cos","sin","gridX","gridY","relX","relY","a","b","baseColors","birch","fir","oak","jungle","createTree","config","treeType","getRandomTreeType","baseSize","round","widthMultiplier","getRandomFloat","heightMultiplier","cacheKey","treeCanvas","get","set","size","firstKey","keys","next","value","delete","speed","opacity","lastUpdateTime","Date","now","update","deltaTime","render","save","globalAlpha","drawImage","restore","types","length","max","setSeason","clear","updateOptions","newOptions","destroy"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/graphics/generators/TreeGenerator.js"],"sourcesContent":["/**\n * Procedural Tree Generator\n * Creates pixel-perfect trees using L-system and fractal algorithms\n * Supports multiple tree types with Mario-style pixel art aesthetic\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\n\nexport class TreeGenerator {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n        this.colorPalette = new ColorPalette();\n\n        // Configuration options\n        this.options = {\n            timeOfDay: options.timeOfDay || 'day',\n            treeTypes: options.treeTypes || ['birch', 'fir', 'oak'],\n            season: options.season || 'summer',\n            pixelSize: options.pixelSize || 8, // 8x8 pixel blocks for retro feel\n            windStrength: options.windStrength || 0.1,\n            animationSpeed: options.animationSpeed || 0.001,\n            ...options\n        };\n\n        this.time = 0;\n        this.treeCache = new Map();\n\n        // Initialize color palette\n        this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n    }    /**\n     * Generate a tree using pixel art style\n     * @param {number} width - Tree width\n     * @param {number} height - Tree height\n     * @param {string} type - Tree type\n     * @returns {Canvas} Generated tree canvas\n     */\n    generateTree(width, height, type = 'oak') {\n        const offscreenCanvas = document.createElement('canvas');\n        const offscreenCtx = offscreenCanvas.getContext('2d');\n        offscreenCanvas.width = width;\n        offscreenCanvas.height = height;\n\n        // Clear canvas with transparent background\n        offscreenCtx.clearRect(0, 0, width, height);\n\n        // Get tree colors based on type and season\n        const treeColors = this.getTreePalette(type);\n        \n        // Grid-based drawing for pixel art style\n        const pixelSize = this.options.pixelSize;\n        const gridWidth = Math.ceil(width / pixelSize);\n        const gridHeight = Math.ceil(height / pixelSize);\n\n        console.log(`Generating ${type} tree: ${width}x${height}, grid: ${gridWidth}x${gridHeight}`);\n\n        // Draw tree based on type\n        try {\n            switch (type) {\n                case 'birch':\n                    this.drawBirchTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                    break;\n                case 'fir':\n                    this.drawFirTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                    break;\n                case 'oak':\n                    this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                    break;\n                case 'jungle':\n                    this.drawJungleTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n                    break;\n                default:\n                    this.drawOakTree(offscreenCtx, gridWidth, gridHeight, pixelSize, treeColors);\n            }\n        } catch (error) {\n            console.error(`Error drawing ${type} tree:`, error);\n            // Draw a simple fallback tree\n            offscreenCtx.fillStyle = '#8B4513';\n            offscreenCtx.fillRect(width/2 - 5, height/2, 10, height/2);\n            offscreenCtx.fillStyle = '#228B22';\n            offscreenCtx.fillRect(width/2 - 15, 0, 30, height/2);\n        }\n\n        return offscreenCanvas;\n    }\n\n    /**\n     * Draw a Mario-style Birch tree\n     */\n    drawBirchTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.7);\n\n        // Draw trunk (white with black stripes for birch)\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX; x++) {\n                // Birch bark pattern - white with horizontal black stripes\n                const isStripe = (y - (gridHeight - trunkHeight)) % 4 === 0;\n                ctx.fillStyle = isStripe ? colors.trunkDark : colors.trunkLight;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw leaves (small, delicate crown)\n        const crownStartY = Math.floor(gridHeight * 0.2);\n        const crownHeight = Math.floor(gridHeight * 0.5);\n\n        for (let y = crownStartY; y < crownStartY + crownHeight; y++) {\n            for (let x = 0; x < gridWidth; x++) {\n                if (this.isBirchLeafPixel(x - centerX, y - crownStartY, gridWidth, crownHeight)) {\n                    ctx.fillStyle = colors.leaves;\n                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Fir tree (Christmas tree shape)\n     */\n    drawFirTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.2);\n\n        // Draw trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw triangular fir shape in layers\n        const layers = 4;\n        const layerHeight = Math.floor((gridHeight - trunkHeight) / layers);\n\n        for (let layer = 0; layer < layers; layer++) {\n            const layerY = layer * layerHeight;\n            const layerBottom = layerY + layerHeight + 2; // Overlap layers\n            const maxWidth = Math.min(gridWidth, (layer + 2) * 3);\n\n            for (let y = layerY; y < layerBottom && y < gridHeight - trunkHeight; y++) {\n                const widthAtY = Math.floor(maxWidth * (y - layerY + 1) / layerHeight);\n                const startX = centerX - Math.floor(widthAtY / 2);\n                const endX = centerX + Math.floor(widthAtY / 2);\n\n                for (let x = startX; x <= endX; x++) {\n                    if (x >= 0 && x < gridWidth) {\n                        // Add some randomness to edges for organic feel\n                        const isEdge = x === startX || x === endX;\n                        if (!isEdge || Math.random() > 0.3) {\n                            ctx.fillStyle = colors.leaves;\n                            ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Oak tree (round crown)\n     */\n    drawOakTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.4);\n\n        // Draw trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 1; x <= centerX + 1; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw round crown\n        const crownCenterY = Math.floor(gridHeight * 0.25);\n        const crownRadius = Math.min(gridWidth / 2 - 1, gridHeight * 0.35);\n\n        for (let y = 0; y < gridHeight - trunkHeight + 2; y++) {\n            for (let x = 0; x < gridWidth; x++) {\n                const dx = x - centerX;\n                const dy = y - crownCenterY;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n\n                // Create bumpy circular crown\n                const noise = this.noiseGenerator.perlin2D(x * 0.3, y * 0.3) * 2;\n                const adjustedRadius = crownRadius + noise;\n\n                if (distance <= adjustedRadius) {\n                    // Add some holes for realistic look\n                    const holeNoise = this.noiseGenerator.perlin2D(x * 0.5, y * 0.5);\n                    if (holeNoise > -0.3) {\n                        ctx.fillStyle = colors.leaves;\n                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a Mario-style Jungle tree (tall with broad leaves)\n     */\n    drawJungleTree(ctx, gridWidth, gridHeight, pixelSize, colors) {\n        const centerX = Math.floor(gridWidth / 2);\n        const trunkHeight = Math.floor(gridHeight * 0.6);\n\n        // Draw tall trunk\n        for (let y = gridHeight - trunkHeight; y < gridHeight; y++) {\n            for (let x = centerX - 2; x <= centerX + 1; x++) {\n                ctx.fillStyle = colors.trunk;\n                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);\n            }\n        }\n\n        // Draw large palm-like leaves at top\n        const crownY = Math.floor(gridHeight * 0.1);\n        const crownHeight = Math.floor(gridHeight * 0.35);\n\n        // Create multiple palm fronds\n        for (let frond = 0; frond < 6; frond++) {\n            const angle = (frond * Math.PI * 2) / 6;\n            const frondLength = Math.min(gridWidth / 2, gridHeight * 0.2);\n\n            for (let i = 0; i < frondLength; i++) {\n                const x = centerX + Math.cos(angle) * i;\n                const y = crownY + crownHeight / 2 + Math.sin(angle) * i * 0.5;\n\n                const gridX = Math.floor(x);\n                const gridY = Math.floor(y);\n\n                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {\n                    ctx.fillStyle = colors.leaves;\n                    ctx.fillRect(gridX * pixelSize, gridY * pixelSize, pixelSize, pixelSize);\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if pixel should be part of birch leaves\n     */\n    isBirchLeafPixel(relX, relY, gridWidth, crownHeight) {\n        // Oval shape for birch crown\n        const a = gridWidth * 0.3;\n        const b = crownHeight * 0.4;\n        return (relX * relX) / (a * a) + (relY * relY) / (b * b) <= 1;\n    }\n\n    /**\n     * Get color palette for tree type and season\n     */\n    getTreePalette(type) {\n        const season = this.options.season;\n        const baseColors = {\n            birch: {\n                trunkLight: '#F8F8F8', // White birch bark\n                trunkDark: '#404040',   // Black stripes\n                trunk: '#E8E8E8',\n                leaves: season === 'autumn' ? '#FFD700' : season === 'winter' ? '#F0F0F0' : '#90EE90'\n            },\n            fir: {\n                trunk: '#8B4513',\n                leaves: season === 'winter' ? '#0F5F0F' : '#228B22' // Darker green\n            },\n            oak: {\n                trunk: '#8B4513',\n                leaves: season === 'autumn' ? '#FF8C00' : season === 'winter' ? '#A0A0A0' : '#32CD32'\n            },\n            jungle: {\n                trunk: '#8B4513',\n                leaves: '#228B22' // Always green\n            }\n        };\n\n        return baseColors[type] || baseColors.oak;\n    }\n\n    /**\n     * Create a tree instance\n     */\n    createTree(config) {\n        const treeType = config.type || this.getRandomTreeType();\n        const baseSize = Math.min(this.canvas.width, this.canvas.height) * 0.15; // Smaller than clouds\n\n        const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.8, 1.2)));\n        const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(1.5, 2.5)));\n\n        // Check cache\n        const cacheKey = `${treeType}_${width}_${height}_${this.options.season}`;\n        let treeCanvas = this.treeCache.get(cacheKey);\n\n        if (!treeCanvas) {\n            treeCanvas = this.generateTree(width, height, treeType);\n            this.treeCache.set(cacheKey, treeCanvas);\n\n            // Limit cache size\n            if (this.treeCache.size > 30) {\n                const firstKey = this.treeCache.keys().next().value;\n                this.treeCache.delete(firstKey);\n            }\n        }\n\n        return {\n            type: 'proceduralTree',\n            x: config.x || this.canvas.width,\n            y: config.y || this.canvas.height - height,\n            width: width,\n            height: height,\n            treeType: treeType,\n            treeCanvas: treeCanvas,\n            speed: config.speed || this.getRandomFloat(0.5, 1.2),\n            opacity: config.opacity || 1.0,\n            lastUpdateTime: Date.now(),\n\n            // Update method\n            update(deltaTime) {\n                // Trees move with the parallax\n                this.x -= this.speed;\n            },\n\n            // Render method\n            render(ctx) {\n                ctx.save();\n                ctx.globalAlpha = this.opacity;\n                ctx.drawImage(this.treeCanvas, this.x, this.y, this.width, this.height);\n                ctx.restore();\n            }\n        };\n    }\n\n    /**\n     * Get random tree type\n     */\n    getRandomTreeType() {\n        const types = this.options.treeTypes;\n        return types[Math.floor(Math.random() * types.length)];\n    }\n\n    /**\n     * Get random float between min and max\n     */\n    getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Update tree generation\n     */\n    update(deltaTime = 16) {\n        this.time += this.options.animationSpeed * deltaTime;\n    }\n\n    /**\n     * Set season and update tree colors\n     */\n    setSeason(season) {\n        this.options.season = season;\n        this.treeCache.clear(); // Regenerate with new season colors\n    }\n\n    /**\n     * Set time of day\n     */\n    setTimeOfDay(timeOfDay) {\n        this.options.timeOfDay = timeOfDay;\n        this.colorPalette.setTimeOfDay(timeOfDay);\n    }\n\n    /**\n     * Update configuration options\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n\n        if (newOptions.season) {\n            this.setSeason(newOptions.season);\n        }\n\n        if (newOptions.timeOfDay) {\n            this.setTimeOfDay(newOptions.timeOfDay);\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.treeCache.clear();\n    }\n}\n\nexport default TreeGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}