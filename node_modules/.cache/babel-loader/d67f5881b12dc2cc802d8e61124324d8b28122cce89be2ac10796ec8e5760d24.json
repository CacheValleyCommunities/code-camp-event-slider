{"ast":null,"code":"var _jsxFileName = \"/Users/brentdalling/Projects/code-camp-event-slider/src/components/Canvas/Canvas.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from \"react\";\nimport \"./Canvas.css\";\nimport SponsorSprite from \"./Sprites/SponsorSprite\";\nimport GrassSprite1 from \"./Sprites/Set/GrassBlock1\";\nimport DirtBlock1Sprite from \"./Sprites/Set/Dirtblock1\";\nimport ProceduralSky from \"./Sprites/ProceduralSky\";\nimport ProceduralCloud from \"./Sprites/ProceduralCloud\";\nimport ProceduralTree from \"./Sprites/ProceduralTree\";\n// console.log = () => null;\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction Canvas() {\n  _s();\n  const canvasRef = useRef(null);\n  const hasSetupBeenCalled = useRef(false);\n  const layers = useRef({\n    background: [],\n    stars: [],\n    mountains: [],\n    clouds: [],\n    trees: [],\n    'trees-2': [],\n    'trees-3': [],\n    'trees-4': [],\n    'trees-5': [],\n    'procedural-trees': [],\n    // Add procedural trees layer\n\n    sprites: [],\n    foreground: []\n  });\n  useEffect(() => {\n    const getRandomStartingXLocation = (canvasWidth, elementWidth) => {\n      // Generate a random X position starting from the right edge of the canvas\n      return getRandomNumber(0, canvasWidth);\n    };\n    const updateSpriteImage = async sprite => {\n      const img = new Image();\n      const nextImage = await sprite.config.getNextImage();\n      img.src = nextImage.url;\n      img.onload = () => {\n        sprite.image = img; // Store the loaded image in the element\n        sprite.width = nextImage.width;\n        sprite.height = nextImage.height;\n      };\n    };\n    const getRandomNumber = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n\n    // Utility function to get a random color representing stars\n    const getRandomColor = () => {\n      const colors = [\"#FFFFFF\",\n      // White\n      \"#FFD700\",\n      // Gold\n      \"#FF4500\",\n      // Orange Red\n      \"#FF8C00\" // Dark Orange\n      ];\n      return colors[Math.floor(Math.random() * colors.length)];\n    };\n    const createElement = async (type, config, layer, delay = 0) => {\n      // Create a promise that resolves after the specified delay\n      if (delay !== 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n      const element = {\n        type,\n        ...config\n      };\n      if (type === \"sprite\") {\n        const img = new Image();\n        try {\n          const nextImage = await config.getNextImage();\n          config.height = nextImage.height;\n          config.width = nextImage.width;\n          img.src = nextImage.url;\n          element.image = img; // Store the loaded image in the element\n        } catch (e) {\n          console.log(\"Something went wrong creating sprite\", e);\n        }\n      }\n      element.config = config;\n\n      // Ensure the layer exists\n      if (!layers.current[layer]) {\n        console.error(`Layer \"${layer}\" does not exist. Available layers:`, Object.keys(layers.current));\n        return; // Exit early if the layer is invalid\n      }\n      layers.current[layer].push(element);\n      return element;\n    };\n    const drawElements = context => {\n      context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n      Object.keys(layers.current).forEach(layer => {\n        layers.current[layer].forEach(element => {\n          if (element.type === \"proceduralSky\") {\n            // Update and render procedural sky (no movement - stays static)\n            element.update();\n            element.render(context, 0); // No offset needed for static sky\n\n            // Sky doesn't move - remove all movement logic\n          } else if (element.type === \"proceduralCloud\") {\n            // Update and render procedural cloud\n            element.update();\n            element.render(context, element.x);\n\n            // Reset cloud position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = Math.random() * context.canvas.height * 0.15 + 20; // Higher Y position to match creation\n            }\n          } else if (element.type === \"proceduralTree\") {\n            // Update and render procedural tree\n            console.log('Rendering procedural tree:', element);\n            element.update();\n            element.render(context, element.x);\n\n            // Reset tree position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = context.canvas.height - element.height; // Keep anchored to ground\n            }\n          } else if (element.type === \"rectangle\") {\n            context.fillStyle = element.color || \"rgba(255, 100, 100, 0.8)\";\n            context.fillRect(element.x, element.y, element.width, element.height);\n\n            // Move rectangle\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && element.config && !element.config.noRegen) {\n              element.x = context.canvas.width;\n            }\n            if (element.config && element.config.perTickTranslation) {\n              const {\n                modifier,\n                xFunc,\n                yFunc\n              } = element.config.perTickTranslation;\n              const yUnitChange = yFunc() * modifier;\n              element.y += yUnitChange * 10;\n              if (xFunc) {\n                const xUnitChange = yFunc() * modifier;\n                element.x += xUnitChange * 10;\n              }\n            }\n          } else if (element.type === \"sprite\") {\n            if (element.image.complete) {\n              context.drawImage(element.image, element.x, element.y, element.width, element.height);\n            }\n\n            // Move sprite\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && !element.config.noRegen) {\n              updateSpriteImage(element);\n              element.x = context.canvas.width; // Reset position to the right\n            }\n          }\n        });\n      });\n    };\n    const animate = context => {\n      drawElements(context);\n      requestAnimationFrame(() => animate(context));\n    };\n    const setup = async () => {\n      hasSetupBeenCalled.current = true;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      canvas.width = 1920;\n      canvas.height = 1080;\n\n      // Create example elements only once\n      if (layers.current.background.length === 0 || true) {\n        // Create procedural sky\n        await createElement(\"proceduralSky\", ProceduralSky(canvas, {\n          timeOfDay: 'night',\n          enableNoise: true,\n          noiseIntensity: 0.015,\n          // Reduced for better performance\n          enableSun: true,\n          // Enable moon for night\n          sunPosition: {\n            x: 0.2,\n            y: 0.15\n          },\n          // Moon position (upper left)\n          automaticTimeOfDay: false,\n          updateInterval: 10000,\n          // Update every 10 seconds for performance\n          animationSpeed: 0.0003 // Very slow animation for night sky\n        }), \"background\");\n        StartShootingStars(getRandomNumber, createElement, getRandomStartingXLocation, canvas, getRandomColor); // Start the first star creation\n\n        let width = 0;\n        const maxWidth = 1920 + 48;\n        const dirtHeight = canvas.height - 100 - 48;\n        const grassHeight = dirtHeight - 48;\n        while (width < maxWidth) {\n          await createElement(\"sprite\", DirtBlock1Sprite({\n            x: width,\n            y: dirtHeight,\n            width: 48,\n            height: 48\n          }), \"foreground\");\n          await createElement(\"sprite\", GrassSprite1({\n            x: width,\n            y: grassHeight,\n            width: 48,\n            height: 48\n          }), \"foreground\");\n          width += 48;\n        }\n        for (let i = 0; i < 100; i++) {\n          const starDimension = getRandomNumber(0.5, 3);\n          createElement(\"rectangle\", {\n            x: getRandomStartingXLocation(canvas.width, 5),\n            y: getRandomNumber(0, canvas.height),\n            width: starDimension,\n            height: starDimension,\n            speed: 0.1,\n            //getRandomNumber(0.01, 0.02),\n            color: getRandomColor(),\n            noRegen: false\n          }, \"stars\");\n        }\n\n        // Create procedural clouds with 8-bit style\n        for (let i = 0; i < 6; i++) {\n          await createElement(\"proceduralCloud\", ProceduralCloud(canvas, {\n            x: getRandomStartingXLocation(canvas.width, 200) + i * 400,\n            y: getRandomNumber(20, canvas.height * 0.15),\n            // Much higher in the sky\n            timeOfDay: 'night',\n            cloudTypes: i % 3 === 0 ? ['cirrus'] : i % 2 === 0 ? ['stratus'] : ['cumulus'],\n            size: getRandomNumber(15, 35) / 100,\n            // Even smaller base size\n            opacity: getRandomNumber(60, 90) / 100,\n            // More visible\n            speed: getRandomNumber(10, 25) / 100,\n            // Slower for retro feel\n            widthMultiplier: getRandomNumber(40, 100) / 100,\n            // Much more variation in width\n            heightMultiplier: getRandomNumber(30, 70) / 100 // Much more variation in height\n          }), \"clouds\");\n        }\n\n        // createForest(canvas); // Replaced with procedural trees\n\n        // Create procedural trees with various types\n        console.log('Starting procedural tree creation...');\n        for (let i = 0; i < 15; i++) {\n          const treeConfig = {\n            x: getRandomNumber(0, canvas.width * 2),\n            // Spread across wider area\n            y: canvas.height - getRandomNumber(80, 150),\n            // Various ground heights\n            timeOfDay: 'night',\n            season: 'summer',\n            treeTypes: ['birch', 'fir', 'oak', 'jungle'],\n            treeType: i % 4 === 0 ? 'birch' : i % 3 === 0 ? 'fir' : i % 2 === 0 ? 'oak' : 'jungle',\n            widthMultiplier: getRandomNumber(80, 120) / 100,\n            heightMultiplier: getRandomNumber(150, 250) / 100,\n            speed: getRandomNumber(40, 80) / 100,\n            // Various speeds for depth\n            opacity: getRandomNumber(80, 100) / 100,\n            pixelSize: 6 // Smaller pixels for detailed look\n          };\n          console.log(`Creating tree ${i + 1}/15:`, treeConfig);\n          const tree = ProceduralTree(canvas, treeConfig);\n          console.log(`Tree ${i + 1} created:`, tree);\n          await createElement(\"proceduralTree\", tree, \"procedural-trees\");\n        }\n        createSponsorBillboard(canvas);\n      }\n      animate(context);\n    };\n    async function createSponsorBillboard(canvas) {\n      let height = canvas.height - 96 * 3 - 300;\n      let coords = {\n        x: 0,\n        y: height - 300 // sprite height - footer height\n      };\n      await createElement(\"sprite\", SponsorSprite(getRandomNumber, canvas, coords), \"foreground\");\n    }\n    function StartShootingStars(getRandomNumber, createElement, getRandomStartingXLocation, canvas, getRandomColor) {\n      let pendingInterval = null;\n      const createStar = async () => {\n        // Wait for a random delay\n        await new Promise(resolve => setTimeout(resolve, getRandomNumber(100, 1000 * 6) * 1));\n\n        // Create a shooting star\n        await createShootingStar(createElement, getRandomStartingXLocation, canvas, getRandomNumber, getRandomColor);\n\n        // Check for the next star\n        pendingInterval = setTimeout(createStar, 1000); // Schedule the next star creation\n      };\n      pendingInterval = setTimeout(createStar, 1000); // Start the first star creation\n      return pendingInterval;\n    }\n    function createShootingStar(createElement, getRandomStartingXLocation, canvas, getRandomNumber, getRandomColor) {\n      const starDir = Math.random() < 0.5 ? -1 : 1;\n      const perYTranslate = getRandomNumber(0.01, 0.5);\n      createElement(\"rectangle\", {\n        x: getRandomStartingXLocation(canvas.width, 5),\n        y: getRandomNumber(200, 500),\n        width: getRandomNumber(1, 12),\n        height: 5,\n        speed: getRandomNumber(10, 20),\n        color: getRandomColor(),\n        noRegen: true,\n        perTickTranslation: {\n          x: -1,\n          y: -0.1,\n          modifier: starDir,\n          yFunc: () => perYTranslate\n        }\n      }, \"stars\", 5000);\n    }\n    if (!hasSetupBeenCalled.current) {\n      setup();\n    }\n  }, [layers]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app-canvas\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 412,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 411,\n    columnNumber: 5\n  }, this);\n}\n_s(Canvas, \"XQXQzfYgGZGvX4LavKWdB/68Njw=\");\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","useEffect","useRef","SponsorSprite","GrassSprite1","DirtBlock1Sprite","ProceduralSky","ProceduralCloud","ProceduralTree","jsxDEV","_jsxDEV","Canvas","_s","canvasRef","hasSetupBeenCalled","layers","background","stars","mountains","clouds","trees","sprites","foreground","getRandomStartingXLocation","canvasWidth","elementWidth","getRandomNumber","updateSpriteImage","sprite","img","Image","nextImage","config","getNextImage","src","url","onload","image","width","height","min","max","Math","floor","random","getRandomColor","colors","length","createElement","type","layer","delay","Promise","resolve","setTimeout","element","e","console","log","current","error","Object","keys","push","drawElements","context","clearRect","canvas","forEach","update","render","x","y","fillStyle","color","fillRect","speed","noRegen","perTickTranslation","modifier","xFunc","yFunc","yUnitChange","xUnitChange","complete","drawImage","animate","requestAnimationFrame","setup","getContext","timeOfDay","enableNoise","noiseIntensity","enableSun","sunPosition","automaticTimeOfDay","updateInterval","animationSpeed","StartShootingStars","maxWidth","dirtHeight","grassHeight","i","starDimension","cloudTypes","size","opacity","widthMultiplier","heightMultiplier","treeConfig","season","treeTypes","treeType","pixelSize","tree","createSponsorBillboard","coords","pendingInterval","createStar","createShootingStar","starDir","perYTranslate","className","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/components/Canvas/Canvas.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\nimport \"./Canvas.css\";\nimport SponsorSprite from \"./Sprites/SponsorSprite\";\nimport GrassSprite1 from \"./Sprites/Set/GrassBlock1\";\nimport DirtBlock1Sprite from \"./Sprites/Set/Dirtblock1\";\nimport ProceduralSky from \"./Sprites/ProceduralSky\";\nimport ProceduralCloud from \"./Sprites/ProceduralCloud\";\nimport ProceduralTree from \"./Sprites/ProceduralTree\";\n// console.log = () => null;\n\nfunction Canvas() {\n  const canvasRef = useRef(null);\n  const hasSetupBeenCalled = useRef(false);\n  const layers = useRef({\n    background: [],\n    stars: [],\n    mountains: [],\n    clouds: [],\n    trees: [],\n    'trees-2': [],\n    'trees-3': [],\n    'trees-4': [],\n    'trees-5': [],\n    'procedural-trees': [], // Add procedural trees layer\n\n    sprites: [],\n    foreground: [],\n  });\n\n  useEffect(() => {\n    const getRandomStartingXLocation = (canvasWidth, elementWidth) => {\n      // Generate a random X position starting from the right edge of the canvas\n      return getRandomNumber(0, canvasWidth);\n    };\n\n    const updateSpriteImage = async (sprite) => {\n      const img = new Image();\n      const nextImage = await sprite.config.getNextImage();\n      img.src = nextImage.url;\n\n      img.onload = () => {\n        sprite.image = img; // Store the loaded image in the element\n        sprite.width = nextImage.width;\n        sprite.height = nextImage.height;\n      };\n    };\n\n    const getRandomNumber = (min, max) => {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    };\n\n    // Utility function to get a random color representing stars\n    const getRandomColor = () => {\n      const colors = [\n        \"#FFFFFF\", // White\n        \"#FFD700\", // Gold\n        \"#FF4500\", // Orange Red\n        \"#FF8C00\", // Dark Orange\n      ];\n\n      return colors[Math.floor(Math.random() * colors.length)];\n    };\n\n    const createElement = async (type, config, layer, delay = 0) => {\n      // Create a promise that resolves after the specified delay\n      if (delay !== 0) {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n\n      const element = { type, ...config };\n\n      if (type === \"sprite\") {\n        const img = new Image();\n        try {\n          const nextImage = await config.getNextImage();\n          config.height = nextImage.height;\n          config.width = nextImage.width;\n          img.src = nextImage.url;\n          element.image = img; // Store the loaded image in the element\n        } catch (e) {\n          console.log(\"Something went wrong creating sprite\", e);\n        }\n      }\n\n      element.config = config;\n\n      // Ensure the layer exists\n      if (!layers.current[layer]) {\n        console.error(\n          `Layer \"${layer}\" does not exist. Available layers:`,\n          Object.keys(layers.current)\n        );\n        return; // Exit early if the layer is invalid\n      }\n\n      layers.current[layer].push(element);\n\n      return element;\n    };\n\n    const drawElements = (context) => {\n      context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n\n      Object.keys(layers.current).forEach((layer) => {\n        layers.current[layer].forEach((element) => {\n          if (element.type === \"proceduralSky\") {\n            // Update and render procedural sky (no movement - stays static)\n            element.update();\n            element.render(context, 0); // No offset needed for static sky\n\n            // Sky doesn't move - remove all movement logic\n          } else if (element.type === \"proceduralCloud\") {\n            // Update and render procedural cloud\n            element.update();\n            element.render(context, element.x);\n\n            // Reset cloud position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = Math.random() * context.canvas.height * 0.15 + 20; // Higher Y position to match creation\n            }\n          } else if (element.type === \"proceduralTree\") {\n            // Update and render procedural tree\n            console.log('Rendering procedural tree:', element);\n            element.update();\n            element.render(context, element.x);\n\n            // Reset tree position when it moves off screen\n            if (element.x + element.width < 0) {\n              element.x = context.canvas.width + element.width;\n              element.y = context.canvas.height - element.height; // Keep anchored to ground\n            }\n          } else if (element.type === \"rectangle\") {\n            context.fillStyle = element.color || \"rgba(255, 100, 100, 0.8)\";\n            context.fillRect(\n              element.x,\n              element.y,\n              element.width,\n              element.height\n            );\n\n            // Move rectangle\n            element.x -= element.speed;\n            if (\n              element.x + element.width < 0 &&\n              element.config &&\n              !element.config.noRegen\n            ) {\n              element.x = context.canvas.width;\n            }\n\n            if (element.config && element.config.perTickTranslation) {\n              const { modifier, xFunc, yFunc } =\n                element.config.perTickTranslation;\n              const yUnitChange = yFunc() * modifier;\n              element.y += yUnitChange * 10;\n\n              if (xFunc) {\n                const xUnitChange = yFunc() * modifier;\n                element.x += xUnitChange * 10;\n              }\n            }\n          } else if (element.type === \"sprite\") {\n            if (element.image.complete) {\n              context.drawImage(\n                element.image,\n                element.x,\n                element.y,\n                element.width,\n                element.height\n              );\n            }\n\n            // Move sprite\n            element.x -= element.speed;\n            if (element.x + element.width < 0 && !element.config.noRegen) {\n              updateSpriteImage(element);\n              element.x = context.canvas.width; // Reset position to the right\n            }\n          }\n        });\n      });\n    };\n\n    const animate = (context) => {\n      drawElements(context);\n      requestAnimationFrame(() => animate(context));\n    };\n\n    const setup = async () => {\n      hasSetupBeenCalled.current = true;\n      const canvas = canvasRef.current;\n      const context = canvas.getContext(\"2d\");\n      canvas.width = 1920;\n      canvas.height = 1080;\n\n      // Create example elements only once\n      if (layers.current.background.length === 0 || true) {\n        // Create procedural sky\n        await createElement(\n          \"proceduralSky\",\n          ProceduralSky(canvas, {\n            timeOfDay: 'night',\n            enableNoise: true,\n            noiseIntensity: 0.015, // Reduced for better performance\n            enableSun: true, // Enable moon for night\n            sunPosition: { x: 0.2, y: 0.15 }, // Moon position (upper left)\n            automaticTimeOfDay: false,\n            updateInterval: 10000, // Update every 10 seconds for performance\n            animationSpeed: 0.0003 // Very slow animation for night sky\n          }),\n          \"background\"\n        );\n\n        StartShootingStars(\n          getRandomNumber,\n          createElement,\n          getRandomStartingXLocation,\n          canvas,\n          getRandomColor\n        ); // Start the first star creation\n\n        let width = 0;\n        const maxWidth = 1920 + 48;\n\n        const dirtHeight = canvas.height - 100 - 48;\n        const grassHeight = dirtHeight - 48;\n\n        while (width < maxWidth) {\n          await createElement(\n            \"sprite\",\n            DirtBlock1Sprite({\n              x: width,\n              y: dirtHeight,\n              width: 48,\n              height: 48,\n            }),\n            \"foreground\"\n          );\n          await createElement(\n            \"sprite\",\n            GrassSprite1({\n              x: width,\n              y: grassHeight,\n              width: 48,\n              height: 48,\n            }),\n            \"foreground\"\n          );\n\n          width += 48;\n        }\n\n        for (let i = 0; i < 100; i++) {\n          const starDimension = getRandomNumber(0.5, 3);\n\n          createElement(\n            \"rectangle\",\n            {\n              x: getRandomStartingXLocation(canvas.width, 5),\n              y: getRandomNumber(0, canvas.height),\n              width: starDimension,\n              height: starDimension,\n              speed: 0.1, //getRandomNumber(0.01, 0.02),\n              color: getRandomColor(),\n              noRegen: false,\n            },\n            \"stars\"\n          );\n        }\n\n        // Create procedural clouds with 8-bit style\n        for (let i = 0; i < 6; i++) {\n          await createElement(\n            \"proceduralCloud\",\n            ProceduralCloud(canvas, {\n              x: getRandomStartingXLocation(canvas.width, 200) + i * 400,\n              y: getRandomNumber(20, canvas.height * 0.15), // Much higher in the sky\n              timeOfDay: 'night',\n              cloudTypes: i % 3 === 0 ? ['cirrus'] : i % 2 === 0 ? ['stratus'] : ['cumulus'],\n              size: getRandomNumber(15, 35) / 100, // Even smaller base size\n              opacity: getRandomNumber(60, 90) / 100, // More visible\n              speed: getRandomNumber(10, 25) / 100,   // Slower for retro feel\n              widthMultiplier: getRandomNumber(40, 100) / 100, // Much more variation in width\n              heightMultiplier: getRandomNumber(30, 70) / 100  // Much more variation in height\n            }),\n            \"clouds\"\n          );\n        }\n\n        // createForest(canvas); // Replaced with procedural trees\n\n        // Create procedural trees with various types\n        console.log('Starting procedural tree creation...');\n        for (let i = 0; i < 15; i++) {\n          const treeConfig = {\n            x: getRandomNumber(0, canvas.width * 2), // Spread across wider area\n            y: canvas.height - getRandomNumber(80, 150), // Various ground heights\n            timeOfDay: 'night',\n            season: 'summer',\n            treeTypes: ['birch', 'fir', 'oak', 'jungle'],\n            treeType: i % 4 === 0 ? 'birch' : i % 3 === 0 ? 'fir' : i % 2 === 0 ? 'oak' : 'jungle',\n            widthMultiplier: getRandomNumber(80, 120) / 100,\n            heightMultiplier: getRandomNumber(150, 250) / 100,\n            speed: getRandomNumber(40, 80) / 100, // Various speeds for depth\n            opacity: getRandomNumber(80, 100) / 100,\n            pixelSize: 6 // Smaller pixels for detailed look\n          };\n          console.log(`Creating tree ${i + 1}/15:`, treeConfig);\n\n          const tree = ProceduralTree(canvas, treeConfig);\n          console.log(`Tree ${i + 1} created:`, tree);\n\n          await createElement(\n            \"proceduralTree\",\n            tree,\n            \"procedural-trees\"\n          );\n        }\n\n        createSponsorBillboard(canvas);\n      }\n\n      animate(context);\n    };\n\n    async function createSponsorBillboard(canvas) {\n      let height = canvas.height - (96 * 3) - 300;\n\n      let coords = {\n        x: 0,\n        y: height - 300, // sprite height - footer height\n      };\n\n      await createElement(\n        \"sprite\",\n        SponsorSprite(getRandomNumber, canvas, coords),\n        \"foreground\"\n      );\n    }\n\n    function StartShootingStars(\n      getRandomNumber,\n      createElement,\n      getRandomStartingXLocation,\n      canvas,\n      getRandomColor\n    ) {\n      let pendingInterval = null;\n\n      const createStar = async () => {\n        // Wait for a random delay\n        await new Promise((resolve) =>\n          setTimeout(resolve, getRandomNumber(100, 1000 * 6) * 1)\n        );\n\n        // Create a shooting star\n        await createShootingStar(\n          createElement,\n          getRandomStartingXLocation,\n          canvas,\n          getRandomNumber,\n          getRandomColor\n        );\n\n        // Check for the next star\n        pendingInterval = setTimeout(createStar, 1000); // Schedule the next star creation\n      };\n\n      pendingInterval = setTimeout(createStar, 1000); // Start the first star creation\n      return pendingInterval;\n    }\n\n    function createShootingStar(\n      createElement,\n      getRandomStartingXLocation,\n      canvas,\n      getRandomNumber,\n      getRandomColor\n    ) {\n      const starDir = Math.random() < 0.5 ? -1 : 1;\n      const perYTranslate = getRandomNumber(0.01, 0.5);\n      createElement(\n        \"rectangle\",\n        {\n          x: getRandomStartingXLocation(canvas.width, 5),\n          y: getRandomNumber(200, 500),\n          width: getRandomNumber(1, 12),\n          height: 5,\n          speed: getRandomNumber(10, 20),\n          color: getRandomColor(),\n          noRegen: true,\n          perTickTranslation: {\n            x: -1,\n            y: -0.1,\n            modifier: starDir,\n            yFunc: () => perYTranslate,\n          },\n        },\n        \"stars\",\n        5000\n      );\n    }\n\n    if (!hasSetupBeenCalled.current) {\n      setup();\n    }\n  }, [layers]);\n\n  return (\n    <div className=\"app-canvas\">\n      <canvas ref={canvasRef}></canvas>\n    </div>\n  );\n}\n\nexport default Canvas;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}