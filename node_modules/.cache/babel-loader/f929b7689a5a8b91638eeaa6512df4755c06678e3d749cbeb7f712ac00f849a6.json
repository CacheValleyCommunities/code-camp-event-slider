{"ast":null,"code":"/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\nexport class CloudGenerator {\n  constructor(canvas, options = {}) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n    this.colorPalette = new ColorPalette();\n\n    // Configuration options\n    this.options = {\n      timeOfDay: options.timeOfDay || 'day',\n      cloudTypes: options.cloudTypes || ['cumulus'],\n      density: options.density || 0.3,\n      size: options.size || 1.0,\n      opacity: options.opacity || 0.8,\n      speed: options.speed || 0.2,\n      noiseScale: options.noiseScale || 0.005,\n      animationSpeed: options.animationSpeed || 0.001,\n      updateInterval: options.updateInterval || 15000,\n      // Update every 15 seconds\n      ...options\n    };\n    this.time = 0;\n    this.lastUpdateTime = 0;\n    this.cloudCache = new Map();\n\n    // Initialize color palette\n    this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n  }\n\n  /**\n   * Generate a single cloud shape using noise\n   * @param {number} width - Cloud width\n   * @param {number} height - Cloud height\n   * @param {string} type - Cloud type ('cumulus', 'stratus', 'cirrus')\n   * @returns {ImageData} Generated cloud image data\n   */\n  generateCloudShape(width, height, type = 'cumulus') {\n    const offscreenCanvas = document.createElement('canvas');\n    const offscreenCtx = offscreenCanvas.getContext('2d');\n    offscreenCanvas.width = width;\n    offscreenCanvas.height = height;\n    const imageData = offscreenCtx.createImageData(width, height);\n    const data = imageData.data;\n    const palette = this.colorPalette.getCurrentPalette();\n\n    // Different noise parameters for different cloud types\n    const cloudParams = this.getCloudParameters(type);\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const i = (y * width + x) * 4;\n\n        // Generate noise value for cloud density\n        const noise1 = this.noiseGenerator.octaveNoise2D(x * cloudParams.scale1 + this.time, y * cloudParams.scale1, cloudParams.octaves1, cloudParams.persistence1);\n        const noise2 = this.noiseGenerator.octaveNoise2D(x * cloudParams.scale2 + this.time * 0.5, y * cloudParams.scale2, cloudParams.octaves2, cloudParams.persistence2);\n\n        // Combine noise values\n        let density = (noise1 + noise2 * 0.5) * 0.5 + 0.5;\n\n        // Apply cloud shape falloff (make clouds more round/organic)\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const distanceFromCenter = Math.sqrt(Math.pow((x - centerX) / width, 2) + Math.pow((y - centerY) / height, 2));\n\n        // Falloff function for natural cloud edges\n        const falloff = Math.max(0, 1 - distanceFromCenter * cloudParams.falloffStrength);\n        density *= falloff;\n\n        // Apply threshold for cloud edges\n        density = Math.max(0, density - cloudParams.threshold);\n        density = Math.min(1, density * cloudParams.contrast);\n        if (density > 0) {\n          // Interpolate between cloud base and highlight colors\n          const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n          const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n          const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * density);\n          const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * density);\n          const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * density);\n          const a = Math.round(density * this.options.opacity * 255);\n          data[i] = r; // Red\n          data[i + 1] = g; // Green\n          data[i + 2] = b; // Blue\n          data[i + 3] = a; // Alpha\n        } else {\n          data[i + 3] = 0; // Transparent\n        }\n      }\n    }\n    offscreenCtx.putImageData(imageData, 0, 0);\n    return offscreenCanvas;\n  }\n\n  /**\n   * Get cloud parameters based on cloud type\n   * @param {string} type - Cloud type\n   * @returns {Object} Cloud generation parameters\n   */\n  getCloudParameters(type) {\n    const params = {\n      cumulus: {\n        scale1: 0.008,\n        scale2: 0.02,\n        octaves1: 4,\n        octaves2: 2,\n        persistence1: 0.6,\n        persistence2: 0.3,\n        falloffStrength: 1.5,\n        threshold: 0.2,\n        contrast: 2.0\n      },\n      stratus: {\n        scale1: 0.003,\n        scale2: 0.01,\n        octaves1: 6,\n        octaves2: 3,\n        persistence1: 0.5,\n        persistence2: 0.4,\n        falloffStrength: 0.8,\n        threshold: 0.1,\n        contrast: 1.5\n      },\n      cirrus: {\n        scale1: 0.015,\n        scale2: 0.04,\n        octaves1: 3,\n        octaves2: 2,\n        persistence1: 0.7,\n        persistence2: 0.2,\n        falloffStrength: 2.0,\n        threshold: 0.3,\n        contrast: 3.0\n      }\n    };\n    return params[type] || params.cumulus;\n  }\n\n  /**\n   * Create a cloud instance\n   * @param {Object} config - Cloud configuration\n   * @returns {Object} Cloud object\n   */\n  createCloud(config) {\n    const cloudType = config.type || this.getRandomCloudType();\n    const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n    const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n    const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n    // Check cache for similar cloud\n    const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n    let cloudCanvas = this.cloudCache.get(cacheKey);\n    if (!cloudCanvas) {\n      cloudCanvas = this.generateCloudShape(width, height, cloudType);\n      this.cloudCache.set(cacheKey, cloudCanvas);\n\n      // Limit cache size\n      if (this.cloudCache.size > 20) {\n        const firstKey = this.cloudCache.keys().next().value;\n        this.cloudCache.delete(firstKey);\n      }\n    }\n    return {\n      type: 'proceduralCloud',\n      x: config.x || this.canvas.width,\n      y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n      width: width,\n      height: height,\n      cloudType: cloudType,\n      cloudCanvas: cloudCanvas,\n      speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n      opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n      lastUpdateTime: Date.now(),\n      // Update method\n      update(deltaTime) {\n        // Clouds don't need frequent updates, just movement\n        this.x -= this.speed;\n      },\n      // Render method\n      render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = this.opacity;\n        ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n        ctx.restore();\n      }\n    };\n  }\n\n  /**\n   * Get random cloud type based on configured types\n   * @returns {string} Cloud type\n   */\n  getRandomCloudType() {\n    const types = this.options.cloudTypes;\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get random float between min and max\n   * @param {number} min - Minimum value\n   * @param {number} max - Maximum value\n   * @returns {number} Random float\n   */\n  getRandomFloat(min, max) {\n    return Math.random() * (max - min) + min;\n  }\n\n  /**\n   * Update cloud generation\n   * @param {number} deltaTime - Time since last update\n   */\n  update(deltaTime = 16) {\n    this.time += this.options.animationSpeed * deltaTime;\n  }\n\n  /**\n   * Set time of day and update cloud colors\n   * @param {string} timeOfDay - New time of day\n   */\n  setTimeOfDay(timeOfDay) {\n    this.options.timeOfDay = timeOfDay;\n    this.colorPalette.setTimeOfDay(timeOfDay);\n    // Clear cache to regenerate clouds with new colors\n    this.cloudCache.clear();\n  }\n\n  /**\n   * Update configuration options\n   * @param {Object} newOptions - New options to apply\n   */\n  updateOptions(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    if (newOptions.timeOfDay) {\n      this.setTimeOfDay(newOptions.timeOfDay);\n    }\n    if (newOptions.seed) {\n      this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n      this.cloudCache.clear();\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  destroy() {\n    this.cloudCache.clear();\n  }\n}\nexport default CloudGenerator;","map":{"version":3,"names":["NoiseGenerator","ColorPalette","CloudGenerator","constructor","canvas","options","ctx","getContext","noiseGenerator","seed","Math","random","colorPalette","timeOfDay","cloudTypes","density","size","opacity","speed","noiseScale","animationSpeed","updateInterval","time","lastUpdateTime","cloudCache","Map","setTimeOfDay","generateCloudShape","width","height","type","offscreenCanvas","document","createElement","offscreenCtx","imageData","createImageData","data","palette","getCurrentPalette","cloudParams","getCloudParameters","y","x","i","noise1","octaveNoise2D","scale1","octaves1","persistence1","noise2","scale2","octaves2","persistence2","centerX","centerY","distanceFromCenter","sqrt","pow","falloff","max","falloffStrength","threshold","min","contrast","baseColor","hexToRgb","cloudBase","highlightColor","cloudHighlight","r","round","g","b","a","putImageData","params","cumulus","stratus","cirrus","createCloud","config","cloudType","getRandomCloudType","baseSize","widthMultiplier","getRandomFloat","heightMultiplier","cacheKey","floor","cloudCanvas","get","set","firstKey","keys","next","value","delete","Date","now","update","deltaTime","render","save","globalAlpha","drawImage","restore","types","length","clear","updateOptions","newOptions","destroy"],"sources":["/Users/brentdalling/Projects/code-camp-event-slider/src/graphics/generators/CloudGenerator.js"],"sourcesContent":["/**\n * Procedural Cloud Generator\n * Creates dynamic cloud shapes using Perlin noise and particle systems\n */\n\nimport NoiseGenerator from '../utils/NoiseGenerator.js';\nimport ColorPalette from '../utils/ColorPalette.js';\n\nexport class CloudGenerator {\n    constructor(canvas, options = {}) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.noiseGenerator = new NoiseGenerator(options.seed || Math.random() * 1000);\n        this.colorPalette = new ColorPalette();\n\n        // Configuration options\n        this.options = {\n            timeOfDay: options.timeOfDay || 'day',\n            cloudTypes: options.cloudTypes || ['cumulus'],\n            density: options.density || 0.3,\n            size: options.size || 1.0,\n            opacity: options.opacity || 0.8,\n            speed: options.speed || 0.2,\n            noiseScale: options.noiseScale || 0.005,\n            animationSpeed: options.animationSpeed || 0.001,\n            updateInterval: options.updateInterval || 15000, // Update every 15 seconds\n            ...options\n        };\n\n        this.time = 0;\n        this.lastUpdateTime = 0;\n        this.cloudCache = new Map();\n\n        // Initialize color palette\n        this.colorPalette.setTimeOfDay(this.options.timeOfDay);\n    }\n\n    /**\n     * Generate a single cloud shape using noise\n     * @param {number} width - Cloud width\n     * @param {number} height - Cloud height\n     * @param {string} type - Cloud type ('cumulus', 'stratus', 'cirrus')\n     * @returns {ImageData} Generated cloud image data\n     */\n    generateCloudShape(width, height, type = 'cumulus') {\n        const offscreenCanvas = document.createElement('canvas');\n        const offscreenCtx = offscreenCanvas.getContext('2d');\n        offscreenCanvas.width = width;\n        offscreenCanvas.height = height;\n\n        const imageData = offscreenCtx.createImageData(width, height);\n        const data = imageData.data;\n        const palette = this.colorPalette.getCurrentPalette();\n\n        // Different noise parameters for different cloud types\n        const cloudParams = this.getCloudParameters(type);\n\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const i = (y * width + x) * 4;\n\n                // Generate noise value for cloud density\n                const noise1 = this.noiseGenerator.octaveNoise2D(\n                    x * cloudParams.scale1 + this.time,\n                    y * cloudParams.scale1,\n                    cloudParams.octaves1,\n                    cloudParams.persistence1\n                );\n\n                const noise2 = this.noiseGenerator.octaveNoise2D(\n                    x * cloudParams.scale2 + this.time * 0.5,\n                    y * cloudParams.scale2,\n                    cloudParams.octaves2,\n                    cloudParams.persistence2\n                );\n\n                // Combine noise values\n                let density = (noise1 + noise2 * 0.5) * 0.5 + 0.5;\n\n                // Apply cloud shape falloff (make clouds more round/organic)\n                const centerX = width / 2;\n                const centerY = height / 2;\n                const distanceFromCenter = Math.sqrt(\n                    Math.pow((x - centerX) / width, 2) +\n                    Math.pow((y - centerY) / height, 2)\n                );\n\n                // Falloff function for natural cloud edges\n                const falloff = Math.max(0, 1 - distanceFromCenter * cloudParams.falloffStrength);\n                density *= falloff;\n\n                // Apply threshold for cloud edges\n                density = Math.max(0, density - cloudParams.threshold);\n                density = Math.min(1, density * cloudParams.contrast);\n\n                if (density > 0) {\n                    // Interpolate between cloud base and highlight colors\n                    const baseColor = this.colorPalette.hexToRgb(palette.cloudBase);\n                    const highlightColor = this.colorPalette.hexToRgb(palette.cloudHighlight);\n\n                    const r = Math.round(baseColor.r + (highlightColor.r - baseColor.r) * density);\n                    const g = Math.round(baseColor.g + (highlightColor.g - baseColor.g) * density);\n                    const b = Math.round(baseColor.b + (highlightColor.b - baseColor.b) * density);\n                    const a = Math.round(density * this.options.opacity * 255);\n\n                    data[i] = r;     // Red\n                    data[i + 1] = g; // Green\n                    data[i + 2] = b; // Blue\n                    data[i + 3] = a; // Alpha\n                } else {\n                    data[i + 3] = 0; // Transparent\n                }\n            }\n        }\n\n        offscreenCtx.putImageData(imageData, 0, 0);\n        return offscreenCanvas;\n    }\n\n    /**\n     * Get cloud parameters based on cloud type\n     * @param {string} type - Cloud type\n     * @returns {Object} Cloud generation parameters\n     */\n    getCloudParameters(type) {\n        const params = {\n            cumulus: {\n                scale1: 0.008,\n                scale2: 0.02,\n                octaves1: 4,\n                octaves2: 2,\n                persistence1: 0.6,\n                persistence2: 0.3,\n                falloffStrength: 1.5,\n                threshold: 0.2,\n                contrast: 2.0\n            },\n            stratus: {\n                scale1: 0.003,\n                scale2: 0.01,\n                octaves1: 6,\n                octaves2: 3,\n                persistence1: 0.5,\n                persistence2: 0.4,\n                falloffStrength: 0.8,\n                threshold: 0.1,\n                contrast: 1.5\n            },\n            cirrus: {\n                scale1: 0.015,\n                scale2: 0.04,\n                octaves1: 3,\n                octaves2: 2,\n                persistence1: 0.7,\n                persistence2: 0.2,\n                falloffStrength: 2.0,\n                threshold: 0.3,\n                contrast: 3.0\n            }\n        };\n\n        return params[type] || params.cumulus;\n    }\n\n    /**\n     * Create a cloud instance\n     * @param {Object} config - Cloud configuration\n     * @returns {Object} Cloud object\n     */\n    createCloud(config) {\n        const cloudType = config.type || this.getRandomCloudType();\n        const baseSize = Math.min(this.canvas.width, this.canvas.height) * this.options.size;\n\n        const width = Math.round(baseSize * (config.widthMultiplier || this.getRandomFloat(0.5, 2.0)));\n        const height = Math.round(baseSize * (config.heightMultiplier || this.getRandomFloat(0.3, 0.8)));\n\n        // Check cache for similar cloud\n        const cacheKey = `${cloudType}_${width}_${height}_${Math.floor(this.time / 1000)}`;\n        let cloudCanvas = this.cloudCache.get(cacheKey);\n\n        if (!cloudCanvas) {\n            cloudCanvas = this.generateCloudShape(width, height, cloudType);\n            this.cloudCache.set(cacheKey, cloudCanvas);\n\n            // Limit cache size\n            if (this.cloudCache.size > 20) {\n                const firstKey = this.cloudCache.keys().next().value;\n                this.cloudCache.delete(firstKey);\n            }\n        }\n\n        return {\n            type: 'proceduralCloud',\n            x: config.x || this.canvas.width,\n            y: config.y || this.getRandomFloat(50, this.canvas.height * 0.4),\n            width: width,\n            height: height,\n            cloudType: cloudType,\n            cloudCanvas: cloudCanvas,\n            speed: this.options.speed * this.getRandomFloat(0.7, 1.3),\n            opacity: this.options.opacity * this.getRandomFloat(0.8, 1.2),\n            lastUpdateTime: Date.now(),\n\n            // Update method\n            update(deltaTime) {\n                // Clouds don't need frequent updates, just movement\n                this.x -= this.speed;\n            },\n\n            // Render method\n            render(ctx) {\n                ctx.save();\n                ctx.globalAlpha = this.opacity;\n                ctx.drawImage(this.cloudCanvas, this.x, this.y, this.width, this.height);\n                ctx.restore();\n            }\n        };\n    }\n\n    /**\n     * Get random cloud type based on configured types\n     * @returns {string} Cloud type\n     */\n    getRandomCloudType() {\n        const types = this.options.cloudTypes;\n        return types[Math.floor(Math.random() * types.length)];\n    }\n\n    /**\n     * Get random float between min and max\n     * @param {number} min - Minimum value\n     * @param {number} max - Maximum value\n     * @returns {number} Random float\n     */\n    getRandomFloat(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n\n    /**\n     * Update cloud generation\n     * @param {number} deltaTime - Time since last update\n     */\n    update(deltaTime = 16) {\n        this.time += this.options.animationSpeed * deltaTime;\n    }\n\n    /**\n     * Set time of day and update cloud colors\n     * @param {string} timeOfDay - New time of day\n     */\n    setTimeOfDay(timeOfDay) {\n        this.options.timeOfDay = timeOfDay;\n        this.colorPalette.setTimeOfDay(timeOfDay);\n        // Clear cache to regenerate clouds with new colors\n        this.cloudCache.clear();\n    }\n\n    /**\n     * Update configuration options\n     * @param {Object} newOptions - New options to apply\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n\n        if (newOptions.timeOfDay) {\n            this.setTimeOfDay(newOptions.timeOfDay);\n        }\n\n        if (newOptions.seed) {\n            this.noiseGenerator = new NoiseGenerator(newOptions.seed);\n            this.cloudCache.clear();\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.cloudCache.clear();\n    }\n}\n\nexport default CloudGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}